(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{1034:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var i={};n.r(i),n.d(i,"default",(function(){return h})),n.d(i,"DEFAULT_NAMESPACE",(function(){return g})),n.d(i,"getNamespace",(function(){return v})),n.d(i,"getColor",(function(){return m})),n.d(i,"getScale",(function(){return P}));var o=n(132),r=n(884);function s(t){return String(t).trim()}function a(){return(a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}function c(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}class l extends r.a{constructor(t,e){super(t=>this.getColor(t)),c(this,"colors",void 0),c(this,"scale",void 0),c(this,"parentForcedColors",void 0),c(this,"forcedColors",void 0),this.colors=t,this.scale=Object(o.a)(),this.scale.range(t),this.parentForcedColors=e,this.forcedColors={}}getColor(t){const e=s(t),n=this.parentForcedColors&&this.parentForcedColors[e];if(n)return n;const i=this.forcedColors[e];return i||this.scale(e)}setColor(t,e){return this.forcedColors[s(t)]=e,this}getColorMap(){const t={};return this.scale.domain().forEach(e=>{t[e.toString()]=this.scale(e)}),a({},t,{},this.forcedColors,{},this.parentForcedColors)}copy(){const t=new l(this.scale.range(),this.parentForcedColors);return t.forcedColors=a({},this.forcedColors),t.domain(this.domain()),t.unknown(this.unknown()),t}domain(t){return void 0===t?this.scale.domain():(this.scale.domain(t),this)}range(t){return void 0===t?this.scale.range():(this.colors=t,this.scale.range(t),this)}unknown(t){return void 0===t?this.scale.unknown():(this.scale.unknown(t),this)}}var u=l,f=n(438);function p(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}class h{constructor(t){p(this,"name",void 0),p(this,"forcedItems",void 0),p(this,"scales",void 0),this.name=t,this.scales={},this.forcedItems={}}getScale(t){var e,n;const i=null!=(e=null!=t?t:Object(f.a)().getDefaultKey())?e:"",o=this.scales[i];if(o)return o;const r=Object(f.a)().get(i),s=new u(null!=(n=null==r?void 0:r.colors)?n:[],this.forcedItems);return this.scales[i]=s,s}setColor(t,e){return this.forcedItems[s(t)]=e,this}}const d={},g="GLOBAL";function v(t=g){const e=d[t];if(e)return e;const n=new h(t);return d[t]=n,n}function m(t,e,n){return v(n).getScale(e).getColor(t)}function P(t,e){return v(e).getScale(t)}},1091:function(t,e,n){"use strict";n.r(e),n.d(e,"getLayer",(function(){return f}));var i=n(975),o=n(1),r=n.n(o),s=n(913),a=n(905),c=n(923),l=n(915);function u(t){return t.object.extraProps&&r.a.createElement("div",{className:"deckgl-tooltip"},Object.keys(t.object.extraProps).map((e,n)=>r.a.createElement(l.a,{key:"prop-"+n,label:e+": ",value:""+t.object.extraProps[e]})))}function f(t,e,n,o){const r=t,c=r.color_picker,l=[c.r,c.g,c.b,255*c.a];let f=e.data.features.map(t=>({...t,path:t.path,width:r.line_width,color:l}));if(r.js_data_mutator){f=Object(a.a)(r.js_data_mutator)(f)}return new i.a({id:"path-layer-"+r.slice_id,getColor:t=>t.color,getPath:t=>t.path,getWidth:t=>t.width,data:f,rounded:!0,widthScale:1,...Object(s.a)(r,o,u)})}e.default=Object(c.b)(f,(function(t){let e=[];return t.forEach(t=>{e=e.concat(t.path)}),e}))},910:function(t,e,n){"use strict";function i(t,e){if((n=(t=e?t.toExponential(e-1):t.toExponential()).indexOf("e"))<0)return null;var n,i=t.slice(0,n);return[i.length>1?i[0]+i.slice(2):i,+t.slice(n+1)]}n.d(e,"b",(function(){return i})),e.a=function(t){return Math.abs(t=Math.round(t))>=1e21?t.toLocaleString("en").replace(/,/g,""):t.toString(10)}},922:function(t,e,n){"use strict";var i=n(910);e.a=function(t){return(t=Object(i.b)(Math.abs(t)))?t[1]:NaN}},923:function(t,e,n){"use strict";n.d(e,"b",(function(){return w})),n.d(e,"a",(function(){return S}));var i=n(1),o=n.n(i),r=n(0),s=n.n(r),a=n(271),c=n(921),l=n(1034),u=n(930),f=n(924),p=n(916),h=n(928),d=n(905),g=n(919);function v(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}const{getScale:m}=l.a;const P={formData:s.a.object.isRequired,mapboxApiKey:s.a.string.isRequired,setControlValue:s.a.func.isRequired,viewport:s.a.object.isRequired,getLayer:s.a.func.isRequired,getPoints:s.a.func.isRequired,payload:s.a.object.isRequired,onAddFilter:s.a.func,width:s.a.number.isRequired,height:s.a.number.isRequired};class y extends o.a.PureComponent{constructor(t){super(t),v(this,"containerRef",o.a.createRef()),v(this,"setTooltip",t=>{const{current:e}=this.containerRef;e&&e.setTooltip(t)}),this.state=this.getStateFromProps(t),this.getLayers=this.getLayers.bind(this),this.onValuesChange=this.onValuesChange.bind(this),this.toggleCategory=this.toggleCategory.bind(this),this.showSingleCategory=this.showSingleCategory.bind(this)}UNSAFE_componentWillReceiveProps(t){t.payload.form_data!==this.state.formData&&this.setState({...this.getStateFromProps(t)})}onValuesChange(t){this.setState({values:Array.isArray(t)?t:[t,t+this.state.getStep(t)]})}getStateFromProps(t,e){const n=t.payload.data.features||[],i=n.map(t=>t.__timestamp),o=function(t,e){const n=t.color_picker||{r:0,g:0,b:0,a:1},i=[n.r,n.g,n.b,255*n.a],o=m(t.color_scheme),r={};return e.forEach(e=>{if(null!=e.cat_color&&!r.hasOwnProperty(e.cat_color)){let s;s=t.dimension?Object(p.hexToRGB)(o(e.cat_color),255*n.a):i,r[e.cat_color]={color:s,enabled:!0}}}),r}(t.formData,n);if(e&&t.payload.form_data===e.formData)return{...e,categories:o};const r=t.payload.form_data.time_grain_sqla||t.payload.form_data.granularity||"P1D",{start:s,end:a,getStep:c,values:l,disabled:u}=Object(h.a)(i,r),{width:f,height:d,formData:v}=t;let{viewport:P}=t;return v.autozoom&&(P=Object(g.a)(P,{width:f,height:d,points:t.getPoints(n)})),{start:s,end:a,getStep:c,values:l,disabled:u,viewport:P,selected:[],lastClick:0,formData:t.payload.form_data,categories:o}}getLayers(t){const{getLayer:e,payload:n,formData:i,onAddFilter:o}=this.props;let r=n.data.features?[...n.data.features]:[];if(r=this.addColor(r,i),i.js_data_mutator){r=Object(d.a)(i.js_data_mutator)(r)}r=t[0]===t[1]||t[1]===this.end?r.filter(e=>e.__timestamp>=t[0]&&e.__timestamp<=t[1]):r.filter(e=>e.__timestamp>=t[0]&&e.__timestamp<t[1]);const s=this.state.categories;i.dimension&&(r=r.filter(t=>s[t.cat_color]&&s[t.cat_color].enabled));return[e(i,{...n,data:{...n.data,features:r}},o,this.setTooltip)]}addColor(t,e){const n=e.color_picker||{r:0,g:0,b:0,a:1},i=m(e.color_scheme);return t.map(t=>{let o;return e.dimension?(o=Object(p.hexToRGB)(i(t.cat_color),255*n.a),{...t,color:o}):t})}toggleCategory(t){const e=this.state.categories[t],n={...this.state.categories,[t]:{...e,enabled:!e.enabled}};Object.values(n).every(t=>!t.enabled)&&Object.values(n).forEach(t=>{t.enabled=!0}),this.setState({categories:n})}showSingleCategory(t){const e={...this.state.categories};Object.values(e).forEach(t=>{t.enabled=!1}),e[t].enabled=!0,this.setState({categories:e})}render(){return o.a.createElement("div",{style:{position:"relative"}},o.a.createElement(u.a,{ref:this.containerRef,getLayers:this.getLayers,start:this.state.start,end:this.state.end,getStep:this.state.getStep,values:this.state.values,disabled:this.state.disabled,viewport:this.state.viewport,mapboxApiAccessToken:this.props.mapboxApiKey,mapStyle:this.props.formData.mapbox_style,setControlValue:this.props.setControlValue,width:this.props.width,height:this.props.height},o.a.createElement(f.a,{categories:this.state.categories,toggleCategory:this.toggleCategory,showSingleCategory:this.showSingleCategory,position:this.props.formData.legend_position,format:this.props.formData.legend_format})))}}function b(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}y.propTypes=P;const x={formData:s.a.object.isRequired,payload:s.a.object.isRequired,setControlValue:s.a.func.isRequired,viewport:s.a.object.isRequired,onAddFilter:s.a.func,width:s.a.number.isRequired,height:s.a.number.isRequired},_={onAddFilter(){}};function w(t,e){class n extends o.a.PureComponent{constructor(t){super(t),b(this,"containerRef",o.a.createRef()),b(this,"setTooltip",t=>{const{current:e}=this.containerRef;e&&e.setTooltip(t)});const{width:n,height:i,formData:r}=t;let{viewport:s}=t;r.autozoom&&(s=Object(g.a)(s,{width:n,height:i,points:e(t.payload.data.features)})),this.state={viewport:s,layer:this.computeLayer(t)},this.onViewportChange=this.onViewportChange.bind(this)}UNSAFE_componentWillReceiveProps(t){const e={...t.formData,viewport:null},n={...this.props.formData,viewport:null};Object(a.isEqual)(e,n)&&t.payload===this.props.payload||this.setState({layer:this.computeLayer(t)})}onViewportChange(t){this.setState({viewport:t})}computeLayer(e){const{formData:n,payload:i,onAddFilter:o}=e;return t(n,i,o,this.setTooltip)}render(){const{formData:t,payload:e,setControlValue:n,height:i,width:r}=this.props,{layer:s,viewport:a}=this.state;return o.a.createElement(c.a,{ref:this.containerRef,mapboxApiAccessToken:e.data.mapboxApiKey,viewport:a,layers:[s],mapStyle:t.mapbox_style,setControlValue:n,width:r,height:i,onViewportChange:this.onViewportChange})}}return n.propTypes=x,n.defaultProps=_,n}function S(t,e){function n(n){const{formData:i,payload:r,setControlValue:s,viewport:a,width:c,height:l}=n;return o.a.createElement(y,{formData:i,mapboxApiKey:r.data.mapboxApiKey,setControlValue:s,viewport:a,getLayer:t,payload:r,getPoints:e,width:c,height:l})}return n.propTypes=x,n.defaultProps=_,n}},924:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var i=n(1),o=n.n(i),r=n(0),s=n.n(r),a=n(999);n(926);const c={categories:s.a.object,toggleCategory:s.a.func,showSingleCategory:s.a.func,format:s.a.string,position:s.a.oneOf([null,"tl","tr","bl","br"])};class l extends o.a.PureComponent{format(t){if(!this.props.format)return t;const e=parseFloat(t);return Object(a.a)(this.props.format,e)}formatCategoryLabel(t){if(!this.props.format)return t;if(t.includes(" - ")){const e=t.split(" - ");return this.format(e[0])+" - "+this.format(e[1])}return this.format(t)}render(){if(0===Object.keys(this.props.categories).length||null===this.props.position)return null;const t=Object.entries(this.props.categories).map(([t,e])=>{const n={color:"rgba("+e.color.join(", ")+")"},i=e.enabled?"◼":"◻";return o.a.createElement("li",{key:t},o.a.createElement("a",{href:"#",onClick:()=>this.props.toggleCategory(t),onDoubleClick:()=>this.props.showSingleCategory(t)},o.a.createElement("span",{style:n},i)," ",this.formatCategoryLabel(t)))}),e={position:"absolute",["t"===this.props.position.charAt(0)?"top":"bottom"]:"0px",["r"===this.props.position.charAt(1)?"right":"left"]:"10px"};return o.a.createElement("div",{className:"legend",style:e},o.a.createElement("ul",{className:"categories"},t))}}l.propTypes=c,l.defaultProps={categories:{},toggleCategory:()=>{},showSingleCategory:()=>{},format:null,position:"tr"}},926:function(t,e,n){var i=n(436),o=n(927);"string"==typeof(o=o.__esModule?o.default:o)&&(o=[[t.i,o,""]]);var r={insert:"head",singleton:!1};i(o,r);t.exports=o.locals||{}},927:function(t,e,n){(e=n(437)(!1)).push([t.i,'/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\ndiv.legend {\n  font-size: 90%;\n  position: absolute;\n  background: #fff;\n  box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);\n  margin: 24px;\n  padding: 12px 20px;\n  outline: none;\n  overflow-y: scroll;\n  max-height: 200px;\n}\n\nul.categories {\n  list-style: none;\n  padding-left: 0;\n  margin: 0;\n}\n\nul.categories li a {\n  color: rgb(51, 51, 51);\n  text-decoration: none;\n}\n\nul.categories li a span {\n  margin-right: 10px;\n}\n',""]),t.exports=e},940:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var i=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function o(t){if(!(e=i.exec(t)))throw new Error("invalid format: "+t);var e;return new r({fill:e[1],align:e[2],sign:e[3],symbol:e[4],zero:e[5],width:e[6],comma:e[7],precision:e[8]&&e[8].slice(1),trim:e[9],type:e[10]})}function r(t){this.fill=void 0===t.fill?" ":t.fill+"",this.align=void 0===t.align?">":t.align+"",this.sign=void 0===t.sign?"-":t.sign+"",this.symbol=void 0===t.symbol?"":t.symbol+"",this.zero=!!t.zero,this.width=void 0===t.width?void 0:+t.width,this.comma=!!t.comma,this.precision=void 0===t.precision?void 0:+t.precision,this.trim=!!t.trim,this.type=void 0===t.type?"":t.type+""}o.prototype=r.prototype,r.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type}},941:function(t,e,n){"use strict";var i,o=n(922),r=n(940),s=n(910),a=function(t,e){var n=Object(s.b)(t,e);if(!n)return t+"";var i=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+i:i.length>o+1?i.slice(0,o+1)+"."+i.slice(o+1):i+new Array(o-i.length+2).join("0")},c={"%":function(t,e){return(100*t).toFixed(e)},b:function(t){return Math.round(t).toString(2)},c:function(t){return t+""},d:s.a,e:function(t,e){return t.toExponential(e)},f:function(t,e){return t.toFixed(e)},g:function(t,e){return t.toPrecision(e)},o:function(t){return Math.round(t).toString(8)},p:function(t,e){return a(100*t,e)},r:a,s:function(t,e){var n=Object(s.b)(t,e);if(!n)return t+"";var o=n[0],r=n[1],a=r-(i=3*Math.max(-8,Math.min(8,Math.floor(r/3))))+1,c=o.length;return a===c?o:a>c?o+new Array(a-c+1).join("0"):a>0?o.slice(0,a)+"."+o.slice(a):"0."+new Array(1-a).join("0")+Object(s.b)(t,Math.max(0,e+a-1))[0]},X:function(t){return Math.round(t).toString(16).toUpperCase()},x:function(t){return Math.round(t).toString(16)}},l=function(t){return t},u=Array.prototype.map,f=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];e.a=function(t){var e,n,s=void 0===t.grouping||void 0===t.thousands?l:(e=u.call(t.grouping,Number),n=t.thousands+"",function(t,i){for(var o=t.length,r=[],s=0,a=e[0],c=0;o>0&&a>0&&(c+a+1>i&&(a=Math.max(1,i-c)),r.push(t.substring(o-=a,o+a)),!((c+=a+1)>i));)a=e[s=(s+1)%e.length];return r.reverse().join(n)}),a=void 0===t.currency?"":t.currency[0]+"",p=void 0===t.currency?"":t.currency[1]+"",h=void 0===t.decimal?".":t.decimal+"",d=void 0===t.numerals?l:function(t){return function(e){return e.replace(/[0-9]/g,(function(e){return t[+e]}))}}(u.call(t.numerals,String)),g=void 0===t.percent?"%":t.percent+"",v=void 0===t.minus?"-":t.minus+"",m=void 0===t.nan?"NaN":t.nan+"";function P(t){var e=(t=Object(r.a)(t)).fill,n=t.align,o=t.sign,l=t.symbol,u=t.zero,P=t.width,y=t.comma,b=t.precision,x=t.trim,_=t.type;"n"===_?(y=!0,_="g"):c[_]||(void 0===b&&(b=12),x=!0,_="g"),(u||"0"===e&&"="===n)&&(u=!0,e="0",n="=");var w="$"===l?a:"#"===l&&/[boxX]/.test(_)?"0"+_.toLowerCase():"",S="$"===l?p:/[%p]/.test(_)?g:"",A=c[_],L=/[defgprs%]/.test(_);function E(t){var r,a,c,l=w,p=S;if("c"===_)p=A(t)+p,t="";else{var g=(t=+t)<0||1/t<0;if(t=isNaN(t)?m:A(Math.abs(t),b),x&&(t=function(t){t:for(var e,n=t.length,i=1,o=-1;i<n;++i)switch(t[i]){case".":o=e=i;break;case"0":0===o&&(o=i),e=i;break;default:if(!+t[i])break t;o>0&&(o=0)}return o>0?t.slice(0,o)+t.slice(e+1):t}(t)),g&&0==+t&&"+"!==o&&(g=!1),l=(g?"("===o?o:v:"-"===o||"("===o?"":o)+l,p=("s"===_?f[8+i/3]:"")+p+(g&&"("===o?")":""),L)for(r=-1,a=t.length;++r<a;)if(48>(c=t.charCodeAt(r))||c>57){p=(46===c?h+t.slice(r+1):t.slice(r))+p,t=t.slice(0,r);break}}y&&!u&&(t=s(t,1/0));var E=l.length+t.length+p.length,C=E<P?new Array(P-E+1).join(e):"";switch(y&&u&&(t=s(C+t,C.length?P-p.length:1/0),C=""),n){case"<":t=l+t+p+C;break;case"=":t=l+C+t+p;break;case"^":t=C.slice(0,E=C.length>>1)+l+t+p+C.slice(E);break;default:t=C+l+t+p}return d(t)}return b=void 0===b?6:/[gprs]/.test(_)?Math.max(1,Math.min(21,b)):Math.max(0,Math.min(20,b)),E.toString=function(){return t+""},E}return{format:P,formatPrefix:function(t,e){var n=P(((t=Object(r.a)(t)).type="f",t)),i=3*Math.max(-8,Math.min(8,Math.floor(Object(o.a)(e)/3))),s=Math.pow(10,-i),a=f[8+i/3];return function(t){return n(s*t)+a}}}}},975:function(t,e,n){"use strict";n.d(e,"a",(function(){return x}));var i=n(894),o=n(895),r=n(897),s=n(896),a=n(909),c=n(898),l=n(960),u=n(1093),f=n(1026),p=n(901),h=n(1250),d=p.a.Tesselator,g=h.a.fp64LowPart,v=function(t){function e(t){var n=t.data,o=t.getGeometry,a=t.positionFormat,c=t.fp64;return Object(i.a)(this,e),Object(r.a)(this,Object(s.a)(e).call(this,{data:n,getGeometry:o,fp64:c,positionFormat:a,attributes:{startPositions:{size:3},endPositions:{size:3},leftPositions:{size:3},rightPositions:{size:3},startEndPositions64XyLow:{size:4,fp64Only:!0},neighborPositions64XyLow:{size:4,fp64Only:!0}}}))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"get",value:function(t){return this.attributes[t]}},{key:"getGeometrySize",value:function(t){return Math.max(0,this.getPathLength(t)-1)}},{key:"updateGeometryAttributes",value:function(t,e){var n=this.attributes,i=n.startPositions,o=n.endPositions,r=n.leftPositions,s=n.rightPositions,a=n.startEndPositions64XyLow,c=n.neighborPositions64XyLow,l=this.fp64,u=e.geometrySize+1;if(!(u<2))for(var f,p=this.isClosed(t),h=this.getPointOnPath(t,0),d=this.getPointOnPath(t,1),v=p?this.getPointOnPath(t,u-2):h,m=e.vertexStart,P=1;P<u;m++,P++)f=P+1<u?this.getPointOnPath(t,P+1):p?this.getPointOnPath(t,1):d,i[3*m]=h[0],i[3*m+1]=h[1],i[3*m+2]=h[2]||0,o[3*m]=d[0],o[3*m+1]=d[1],o[3*m+2]=d[2]||0,r[3*m]=v[0],r[3*m+1]=v[1],r[3*m+2]=v[2]||0,s[3*m]=f[0],s[3*m+1]=f[1],s[3*m+2]=f[2]||0,l&&(a[4*m]=g(h[0]),a[4*m+1]=g(h[1]),a[4*m+2]=g(d[0]),a[4*m+3]=g(d[1]),c[4*m]=g(v[0]),c[4*m+1]=g(v[1]),c[4*m+2]=g(f[0]),c[4*m+3]=g(f[1])),v=h,h=d,d=f}},{key:"getPathLength",value:function(t){return Number.isFinite(t[0])?t.length/this.positionSize:t.length}},{key:"getPointOnPath",value:function(t,e){if(Number.isFinite(t[0])){var n=this.positionSize;return[t[e*n],t[e*n+1],3===n?t[e*n+2]:0]}return t[e]}},{key:"isClosed",value:function(t){var e=this.getPathLength(t),n=this.getPointOnPath(t,0),i=this.getPointOnPath(t,e-1);return n[0]===i[0]&&n[1]===i[1]&&n[2]===i[2]}}]),e}(d),m="#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\nuniform float alignMode;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\nbool dash_isFragInGap() {\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = alignMode * solidLength / 2.0;\n\n  return gapLength > 0.0 &&\n    vPathPosition.y >= 0.0 &&\n    vPathPosition.y <= vPathLength &&\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\n}\n\nvoid main(void) {\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\n    discard;\n  }\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n",P=[0,0,0,255],y={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},rounded:!1,miterLimit:{type:"number",min:0,value:4},fp64:!1,dashJustified:!1,billboard:!1,getPath:{type:"accessor",value:function(t){return t.path}},getColor:{type:"accessor",value:P},getWidth:{type:"accessor",value:1},getDashArray:{type:"accessor",value:[0,0]}},b={enter:function(t,e){return e.length?e.subarray(e.length-t.length):t}},x=function(t){function e(){return Object(i.a)(this,e),Object(r.a)(this,Object(s.a)(e).apply(this,arguments))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"getShaders",value:function(){return this.use64bitProjection()?{vs:"\n#define SHADER_NAME path-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\nvec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {\n\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n  float width = project_pixel_size(widthPixels);\n\n  vec2 deltaA64[2];\n  vec2 deltaB64[2];\n\n  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);\n  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);\n\n  vec2 lengthA64 = vec2_length_fp64(deltaA64);\n  vec2 lengthB64 = vec2_length_fp64(deltaB64);\n\n  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);\n  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);\n\n  float lenA = lengthA64.x;\n  float lenB = lengthB64.x;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\n  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  float isStartCap = step(lenA, 1.0e-5);\n  float isEndCap = step(lenB, 1.0e-5);\n  float isCap = max(isStartCap, isEndCap);\n  cornerPosition = isCap * (1.0 - positions.z);\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L / width;\n  float isEnd = positions.x;\n  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);\n  vec2 dir = mix(dirB, dirA, isEnd);\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);\n  float projected_curr_position_z = project_size(currPosition.z);\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec2 projected_prev_position[2];\n  project_position_fp64(prevPosition.xy, prevPosition64xyLow, projected_prev_position);\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  vec2 projected_next_position[2];\n  project_position_fp64(nextPosition.xy, nextPosition64xyLow, projected_next_position);\n\n  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);\n  vec2 vertex_pos_modelspace[4];\n\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\n}\n",fs:m,modules:["project64","picking"]}:{vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  float relativePosition, bool isEnd, bool isJoint,\n  vec2 width\n) {\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  lenA = lenA > EPSILON ? lenA : 0.0;\n  lenB = lenB > EPSILON ? lenB : 0.0;\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  float cornerPosition = isJoint ?\n    0.0 :\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\n  cornerPosition *=\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\n  if (cornerPosition < 0.0) {\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\n  }\n\n  vMiterLength = cornerPosition >= 0.0 ?\n    mix(offsetScale, 0.0, cornerPosition) :\n    offsetScale * cornerPosition;\n  vMiterLength -= sinHalfA * jointType;\n\n  float offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  bool isStartCap = step(0.0, -lenA) > 0.5;\n  bool isEndCap = step(0.0, -lenB) > 0.5;\n  bool isCap = isStartCap || isEndCap;\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\n  if (isStartCap) {\n    offsetVec = mix(dirB, perpB, cornerPosition);\n  }\n  if (isEndCap) {\n    offsetVec = mix(dirA, perpA, cornerPosition);\n  }\n  if (isCap) {\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\n    vMiterLength = 1.0 - cornerPosition;\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\n  }\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L;\n  vec2 offsetFromStartOfPath = vCornerOffset;\n  if (isEnd) {\n    offsetFromStartOfPath += deltaA;\n  }\n  vec2 dir = isEnd ? dirA : dirB;\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return currPoint + vec3(vCornerOffset * width, 0.0);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float relativePosition = positions.y;\n  bool isEnd = positions.x > EPSILON;\n  bool isJoint = positions.z > EPSILON;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  return lineJoin(\n    prevPoint, currPoint, nextPoint,\n    relativePosition, isEnd, isJoint,\n    billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels)\n  );\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\n    currPosition = project_position(currPosition, currPosition64xyLow);\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\n\n    vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n    gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));\n  }\n}\n",fs:m,modules:["project32","picking"]}}},{key:"initializeState",value:function(){var t=this;this.getAttributeManager().addInstanced({instanceStartPositions:{size:3,transition:b,accessor:"getPath",update:this.calculateStartPositions,noAlloc:!0},instanceEndPositions:{size:3,transition:b,accessor:"getPath",update:this.calculateEndPositions,noAlloc:!0},instanceStartEndPositions64xyLow:{size:4,update:this.calculateInstanceStartEndPositions64xyLow,noAlloc:!0},instanceLeftPositions:{size:3,accessor:"getPath",update:this.calculateLeftPositions,noAlloc:!0},instanceRightPositions:{size:3,accessor:"getPath",update:this.calculateRightPositions,noAlloc:!0},instanceNeighborPositions64xyLow:{size:4,update:this.calculateInstanceNeighborPositions64xyLow,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:b,defaultValue:1},instanceDashArrays:{size:2,accessor:"getDashArray"},instanceColors:{size:4,type:5121,accessor:"getColor",transition:b,defaultValue:P},instancePickingColors:{size:3,type:5121,accessor:function(e,n){var i=n.index,o=n.target;return t.encodePickingColor(i,o)}}}),this.setState({pathTesselator:new v({})})}},{key:"updateState",value:function(t){var n=t.oldProps,i=t.props,o=t.changeFlags;Object(a.a)(Object(s.a)(e.prototype),"updateState",this).call(this,{props:i,oldProps:n,changeFlags:o});var r=this.getAttributeManager();if(o.dataChanged||i.fp64!==n.fp64||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPath)){var c=this.state.pathTesselator;c.updateGeometry({data:i.data,getGeometry:i.getPath,positionFormat:i.positionFormat,fp64:this.use64bitPositions()}),this.setState({numInstances:c.instanceCount,bufferLayout:c.bufferLayout}),r.invalidateAll()}if(i.fp64!==n.fp64){var l=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(l)}),r.invalidateAll()}}},{key:"draw",value:function(t){var e=t.uniforms,n=this.context.viewport,i=this.props,o=i.rounded,r=i.billboard,s=i.miterLimit,a=i.widthUnits,c=i.widthScale,l=i.widthMinPixels,u=i.widthMaxPixels,f=i.dashJustified,p="pixels"===a?n.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},e,{jointType:Number(o),billboard:r,alignMode:Number(f),widthScale:c*p,miterLimit:s,widthMinPixels:l,widthMaxPixels:u})).draw()}},{key:"_getModel",value:function(t){return new u.a(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new f.a({drawMode:4,attributes:{indices:new Uint16Array([0,2,1,1,2,4,1,4,3,3,4,5]),positions:new Float32Array([0,0,1,0,-1,0,0,1,0,1,-1,0,1,1,0,1,0,1])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}},{key:"calculateStartPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("startPositions")}},{key:"calculateEndPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("endPositions")}},{key:"calculateInstanceStartEndPositions64xyLow",value:function(t){var e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("startEndPositions64XyLow"):new Float32Array(4)}},{key:"calculateLeftPositions",value:function(t){var e=this.state.pathTesselator;t.value=e.get("leftPositions")}},{key:"calculateRightPositions",value:function(t){var e=this.state.pathTesselator;t.value=e.get("rightPositions")}},{key:"calculateInstanceNeighborPositions64xyLow",value:function(t){var e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("neighborPositions64XyLow"):new Float32Array(4)}},{key:"clearPickingColor",value:function(t){for(var e=this.decodePickingColor(t),n=this.state.pathTesselator.bufferLayout,i=n[e],o=0,r=0;r<e;r++)o+=n[r];var s=this.getAttributeManager().attributes.instancePickingColors,a=s.value,c=o+i;a.fill(0,3*o,3*c),s.update({value:a})}}]),e}(l.a);x.layerName="PathLayer",x.defaultProps=y},993:function(t,e,n){"use strict";n.d(e,"a",(function(){return o})),n.d(e,"b",(function(){return r}));var i,o,r,s,a=n(941);s={decimal:".",thousands:",",grouping:[3],currency:["$",""],minus:"-"},i=Object(a.a)(s),o=i.format,r=i.formatPrefix},999:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var i=n(105),o=n(872),r=n(36),s=n(993),a=n(941),c=n(882),l=n(884);function u(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}class f extends l.a{constructor(t){super(t=>this.format(t)),u(this,"id",void 0),u(this,"label",void 0),u(this,"description",void 0),u(this,"formatFunc",void 0),u(this,"isInvalid",void 0);const{id:e=Object(c.a)("config.id"),label:n,description:i="",formatFunc:o=Object(c.a)("config.formatFunc"),isInvalid:r=!1}=t;this.id=e,this.label=null!=n?n:e,this.description=i,this.formatFunc=o,this.isInvalid=r}format(t){return null==t||Number.isNaN(t)?""+t:t===Number.POSITIVE_INFINITY?"∞":t===Number.NEGATIVE_INFINITY?"-∞":this.formatFunc(t)}preview(t=12345.432){return t+" => "+this.format(t)}}var p=f;var h={DOLLAR:"$,.2f",DOLLAR_ROUND:"$,d",DOLLAR_ROUND_SIGNED:"+$,d",DOLLAR_SIGNED:"+$,.2f",FLOAT:",.2f",FLOAT_1_POINT:",.1f",FLOAT_2_POINT:",.2f",FLOAT_3_POINT:",.3f",FLOAT_SIGNED:"+,.2f",FLOAT_SIGNED_1_POINT:"+,.1f",FLOAT_SIGNED_2_POINT:"+,.2f",FLOAT_SIGNED_3_POINT:"+,.3f",INTEGER:",d",INTEGER_SIGNED:"+,d",PERCENT:",.2%",PERCENT_1_POINT:",.1%",PERCENT_2_POINT:",.2%",PERCENT_3_POINT:",.3%",PERCENT_SIGNED:"+,.2%",PERCENT_SIGNED_1_POINT:"+,.1%",PERCENT_SIGNED_2_POINT:"+,.2%",PERCENT_SIGNED_3_POINT:"+,.3%",SI:".3s",SI_1_DIGIT:".1s",SI_2_DIGIT:".2s",SI_3_DIGIT:".3s",SMART_NUMBER:"SMART_NUMBER",SMART_NUMBER_SIGNED:"SMART_NUMBER_SIGNED"};const d=Object(s.a)(".3~s"),g=Object(s.a)(".2~f"),v=Object(s.a)(".4~f");function m(t={}){const{description:e,signed:n=!1,id:i,label:o}=t,r=n?t=>t>0?"+":"":()=>"";return new p({description:e,formatFunc:t=>""+r(t)+function(t){if(0===t)return"0";const e=Math.abs(t);return e>=1e3?d(t).replace("G","B"):e>=1?g(t):e>=.001?v(t):e>1e-6?d(1e6*t)+"µ":d(t)}(t),id:i||n?h.SMART_NUMBER_SIGNED:h.SMART_NUMBER,label:null!=o?o:"Adaptive formatter"})}class P extends o.a{constructor(){super({name:"NumberFormatter",overwritePolicy:r.a.WARN}),this.registerValue(h.SMART_NUMBER,m()),this.registerValue(h.SMART_NUMBER_SIGNED,m({signed:!0})),this.setDefaultKey(h.SMART_NUMBER)}get(t){const e=(""+(null==t||""===t?this.defaultKey:t)).trim();if(this.has(e))return super.get(e);const n=function(t){const{description:e,formatString:n=Object(c.a)("config.formatString"),label:i,locale:o}=t;let r,l=!1;try{r=void 0===o?Object(s.a)(n):Object(a.a)(o).format(n)}catch(t){r=t=>t+" (Invalid format: "+n+")",l=!0}return new p({description:e,formatFunc:r,id:n,isInvalid:l,label:i})}({formatString:e});return this.registerValue(e,n),n}format(t,e){return this.get(t)(e)}}const y=Object(i.a)(P);function b(t,e){return y().format(t,e)}}}]);