(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{732:function(t,e,n){"use strict";var i=n(0),o=n.n(i),r=n(1),a=n.n(r),s=n(763),c=n(727),l=n(691),p=n(736),f=n(733),u=n(723),d=n(734),h=n(719),v=n(718);function g(){return(g=Object.assign||function(t){for(var e,n=1;n<arguments.length;n++)for(var i in e=arguments[n])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)}function P(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var y=l.a.getScale;var m={formData:a.a.object.isRequired,mapboxApiKey:a.a.string.isRequired,setControlValue:a.a.func.isRequired,viewport:a.a.object.isRequired,getLayer:a.a.func.isRequired,getPoints:a.a.func.isRequired,payload:a.a.object.isRequired,onAddFilter:a.a.func,setTooltip:a.a.func,width:a.a.number.isRequired,height:a.a.number.isRequired},x=function(t){function e(e){var n;return(n=t.call(this,e)||this).state=n.getStateFromProps(e),n.getLayers=n.getLayers.bind(P(n)),n.onValuesChange=n.onValuesChange.bind(P(n)),n.toggleCategory=n.toggleCategory.bind(P(n)),n.showSingleCategory=n.showSingleCategory.bind(P(n)),n}!function(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}(e,t);var n=e.prototype;return n.UNSAFE_componentWillReceiveProps=function(t){t.payload.form_data!==this.state.formData&&this.setState(g({},this.getStateFromProps(t)))},n.onValuesChange=function(t){this.setState({values:Array.isArray(t)?t:[t,t+this.state.getStep(t)]})},n.getStateFromProps=function(t,e){var n=t.payload.data.features||[],i=n.map((function(t){return t.__timestamp})),o=function(t,e){var n=t.color_picker||{r:0,g:0,b:0,a:1},i=[n.r,n.g,n.b,255*n.a],o=y(t.color_scheme),r={};return e.forEach((function(e){var a;null==e.cat_color||r.hasOwnProperty(e.cat_color)||(a=t.dimension?Object(u.hexToRGB)(o(e.cat_color),255*n.a):i,r[e.cat_color]={color:a,enabled:!0})})),r}(t.formData,n);if(e&&t.payload.form_data===e.formData)return g({},e,{categories:o});var r=t.payload.form_data.time_grain_sqla||t.payload.form_data.granularity||"P1D",a=Object(d.a)(i,r);return{start:a.start,end:a.end,getStep:a.getStep,values:a.values,disabled:a.disabled,viewport:t.formData.autozoom?Object(v.b)(t.viewport,t.getPoints(n)):t.viewport,selected:[],lastClick:0,formData:t.payload.form_data,categories:o}},n.getLayers=function(t){var e=this.props,n=e.getLayer,i=e.payload,o=e.formData,r=e.onAddFilter,a=e.setTooltip,s=i.data.features?[].concat(i.data.features):[];(s=this.addColor(s,o),o.js_data_mutator)&&(s=Object(h.a)(o.js_data_mutator)(s));s=t[0]===t[1]||t[1]===this.end?s.filter((function(e){return e.__timestamp>=t[0]&&e.__timestamp<=t[1]})):s.filter((function(e){return e.__timestamp>=t[0]&&e.__timestamp<t[1]}));var c=this.state.categories;return o.dimension&&(s=s.filter((function(t){return c[t.cat_color]&&c[t.cat_color].enabled}))),[n(o,g({},i,{data:g({},i.data,{features:s})}),r,a)]},n.addColor=function(t,e){var n=e.color_picker||{r:0,g:0,b:0,a:1},i=y(e.color_scheme);return t.map((function(t){return e.dimension?g({},t,{color:Object(u.hexToRGB)(i(t.cat_color),255*n.a)}):t}))},n.toggleCategory=function(t){var e,n=this.state.categories[t],i=g({},this.state.categories,((e={})[t]=g({},n,{enabled:!n.enabled}),e));Object.values(i).every((function(t){return!t.enabled}))&&Object.values(i).forEach((function(t){t.enabled=!0})),this.setState({categories:i})},n.showSingleCategory=function(t){var e=g({},this.state.categories);Object.values(e).forEach((function(t){t.enabled=!1})),e[t].enabled=!0,this.setState({categories:e})},n.render=function(){return o.a.createElement("div",{style:{position:"relative"}},o.a.createElement(p.a,{getLayers:this.getLayers,start:this.state.start,end:this.state.end,getStep:this.state.getStep,values:this.state.values,onValuesChange:this.onValuesChange,disabled:this.state.disabled,viewport:this.state.viewport,mapboxApiAccessToken:this.props.mapboxApiKey,mapStyle:this.props.formData.mapbox_style,setControlValue:this.props.setControlValue,width:this.props.width,height:this.props.height},o.a.createElement(f.a,{categories:this.state.categories,toggleCategory:this.toggleCategory,showSingleCategory:this.showSingleCategory,position:this.props.formData.legend_position,format:this.props.formData.legend_format})))},e}(o.a.PureComponent);function b(){return(b=Object.assign||function(t){for(var e,n=1;n<arguments.length;n++)for(var i in e=arguments[n])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)}x.propTypes=m,n.d(e,"b",(function(){return S})),n.d(e,"a",(function(){return L}));var w={formData:a.a.object.isRequired,payload:a.a.object.isRequired,setControlValue:a.a.func.isRequired,viewport:a.a.object.isRequired,onAddFilter:a.a.func,setTooltip:a.a.func,width:a.a.number.isRequired,height:a.a.number.isRequired},_={onAddFilter:function(){},setTooltip:function(){}};function S(t,e){var n=function(n){function i(t){var i=n.call(this,t)||this,o=t.viewport,r=t.formData.autozoom?Object(v.b)(o,e(t.payload.data.features)):o;return i.state={viewport:r,layer:i.computeLayer(t)},i.onViewportChange=i.onViewportChange.bind(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(i)),i}!function(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}(i,n);var r=i.prototype;return r.UNSAFE_componentWillReceiveProps=function(t){var e=b({},t.formData,{viewport:null}),n=b({},this.props.formData,{viewport:null});Object(s.isEqual)(e,n)&&t.payload===this.props.payload||this.setState({layer:this.computeLayer(t)})},r.onViewportChange=function(t){this.setState({viewport:t})},r.computeLayer=function(e){var n=e.formData,i=e.payload,o=e.onAddFilter,r=e.setTooltip;return t(n,i,o,r)},r.render=function(){var t=this.props,e=t.formData,n=t.payload,i=t.setControlValue,r=t.height,a=t.width,s=this.state,l=s.layer,p=s.viewport;return o.a.createElement(c.a,{mapboxApiAccessToken:n.data.mapboxApiKey,viewport:p,layers:[l],mapStyle:e.mapbox_style,setControlValue:i,onViewportChange:this.onViewportChange,width:a,height:r})},i}(o.a.PureComponent);return n.propTypes=w,n.defaultProps=_,n}function L(t,e){function n(n){var i=n.formData,r=n.payload,a=n.setControlValue,s=n.onAddFilter,c=n.setTooltip,l=n.viewport,p=n.width,f=n.height;return o.a.createElement(x,{formData:i,mapboxApiKey:r.data.mapboxApiKey,setControlValue:a,viewport:l,getLayer:t,payload:r,onAddFilter:s,setTooltip:c,getPoints:e,width:p,height:f})}return n.propTypes=w,n.defaultProps=_,n}},733:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var i=n(0),o=n.n(i),r=n(1),a=n.n(r),s=n(1045);n(737);var c={categories:a.a.object,toggleCategory:a.a.func,showSingleCategory:a.a.func,format:a.a.string,position:a.a.oneOf([null,"tl","tr","bl","br"])},l=function(t){function e(){return t.apply(this,arguments)||this}!function(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}(e,t);var n=e.prototype;return n.format=function(t){if(!this.props.format)return t;var e=parseFloat(t);return Object(s.a)(this.props.format,e)},n.formatCategoryLabel=function(t){if(!this.props.format)return t;if(t.includes(" - ")){var e=t.split(" - ");return this.format(e[0])+" - "+this.format(e[1])}return this.format(t)},n.render=function(){var t,e=this;if(0===Object.keys(this.props.categories).length||null===this.props.position)return null;var n=Object.entries(this.props.categories).map((function(t){var n=t[0],i=t[1],r={color:"rgba("+i.color.join(", ")+")"},a=i.enabled?"◼":"◻";return o.a.createElement("li",{key:n},o.a.createElement("a",{href:"#",onClick:function(){return e.props.toggleCategory(n)},onDoubleClick:function(){return e.props.showSingleCategory(n)}},o.a.createElement("span",{style:r},a)," ",e.formatCategoryLabel(n)))})),i="t"===this.props.position.charAt(0)?"top":"bottom",r="r"===this.props.position.charAt(1)?"right":"left",a=((t={position:"absolute"})[i]="0px",t[r]="10px",t);return o.a.createElement("div",{className:"legend",style:a},o.a.createElement("ul",{className:"categories"},n))},e}(o.a.PureComponent);l.propTypes=c,l.defaultProps={categories:{},toggleCategory:function(){},showSingleCategory:function(){},format:null,position:"tr"}},737:function(t,e,n){var i=n(738);"string"==typeof i&&(i=[[t.i,i,""]]);var o={hmr:!0,transform:void 0,insertInto:void 0};n(341)(i,o);i.locals&&(t.exports=i.locals)},738:function(t,e,n){(t.exports=n(340)(!1)).push([t.i,'/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\ndiv.legend {\n    font-size: 90%;\n    position: absolute;\n    background: #fff;\n    box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);\n    margin: 24px;\n    padding: 12px 20px;\n    outline: none;\n    overflow-y: scroll;\n    max-height: 200px;\n}\n\nul.categories {\n    list-style: none;\n    padding-left: 0;\n    margin: 0;\n}\n\nul.categories li a {\n    color: rgb(51, 51, 51);\n    text-decoration: none;\n}\n\nul.categories li a span {\n    margin-right: 10px;\n}\n',""])},800:function(t,e,n){"use strict";var i=n(709),o=n(710),r=n(711),a=n(211),s=n(720),c=n(712),l=n(784),p=n(919),f=n(846),u=n(715),d=n(1074),h=u.a.Tesselator,v=d.a.fp64LowPart,g=function(t){function e(t){var n=t.data,o=t.getGeometry,s=t.positionFormat,c=t.fp64;return Object(i.a)(this,e),Object(r.a)(this,Object(a.a)(e).call(this,{data:n,getGeometry:o,fp64:c,positionFormat:s,attributes:{startPositions:{size:3},endPositions:{size:3},leftPositions:{size:3},rightPositions:{size:3},startEndPositions64XyLow:{size:4,fp64Only:!0},neighborPositions64XyLow:{size:4,fp64Only:!0}}}))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"get",value:function(t){return this.attributes[t]}},{key:"getGeometrySize",value:function(t){return Math.max(0,this.getPathLength(t)-1)}},{key:"updateGeometryAttributes",value:function(t,e){var n=this.attributes,i=n.startPositions,o=n.endPositions,r=n.leftPositions,a=n.rightPositions,s=n.startEndPositions64XyLow,c=n.neighborPositions64XyLow,l=this.fp64,p=e.geometrySize+1;if(!(p<2))for(var f,u=this.isClosed(t),d=this.getPointOnPath(t,0),h=this.getPointOnPath(t,1),g=u?this.getPointOnPath(t,p-2):d,P=e.vertexStart,y=1;y<p;P++,y++)f=y+1<p?this.getPointOnPath(t,y+1):u?this.getPointOnPath(t,1):h,i[3*P]=d[0],i[3*P+1]=d[1],i[3*P+2]=d[2]||0,o[3*P]=h[0],o[3*P+1]=h[1],o[3*P+2]=h[2]||0,r[3*P]=g[0],r[3*P+1]=g[1],r[3*P+2]=g[2]||0,a[3*P]=f[0],a[3*P+1]=f[1],a[3*P+2]=f[2]||0,l&&(s[4*P]=v(d[0]),s[4*P+1]=v(d[1]),s[4*P+2]=v(h[0]),s[4*P+3]=v(h[1]),c[4*P]=v(g[0]),c[4*P+1]=v(g[1]),c[4*P+2]=v(f[0]),c[4*P+3]=v(f[1])),g=d,d=h,h=f}},{key:"getPathLength",value:function(t){return Number.isFinite(t[0])?t.length/this.positionSize:t.length}},{key:"getPointOnPath",value:function(t,e){if(Number.isFinite(t[0])){var n=this.positionSize;return[t[e*n],t[e*n+1],3===n?t[e*n+2]:0]}return t[e]}},{key:"isClosed",value:function(t){var e=this.getPathLength(t),n=this.getPointOnPath(t,0),i=this.getPointOnPath(t,e-1);return n[0]===i[0]&&n[1]===i[1]&&n[2]===i[2]}}]),e}(h),P="#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\nuniform float alignMode;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\nbool dash_isFragInGap() {\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = alignMode * solidLength / 2.0;\n\n  return gapLength > 0.0 &&\n    vPathPosition.y >= 0.0 &&\n    vPathPosition.y <= vPathLength &&\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\n}\n\nvoid main(void) {\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\n    discard;\n  }\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";n.d(e,"a",(function(){return b}));var y=[0,0,0,255],m={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},rounded:!1,miterLimit:{type:"number",min:0,value:4},fp64:!1,dashJustified:!1,billboard:!1,getPath:{type:"accessor",value:function(t){return t.path}},getColor:{type:"accessor",value:y},getWidth:{type:"accessor",value:1},getDashArray:{type:"accessor",value:[0,0]}},x={enter:function(t,e){return e.length?e.subarray(e.length-t.length):t}},b=function(t){function e(){return Object(i.a)(this,e),Object(r.a)(this,Object(a.a)(e).apply(this,arguments))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"getShaders",value:function(){return this.use64bitProjection()?{vs:"\n#define SHADER_NAME path-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\nvec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {\n\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n  float width = project_pixel_size(widthPixels);\n\n  vec2 deltaA64[2];\n  vec2 deltaB64[2];\n\n  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);\n  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);\n\n  vec2 lengthA64 = vec2_length_fp64(deltaA64);\n  vec2 lengthB64 = vec2_length_fp64(deltaB64);\n\n  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);\n  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);\n\n  float lenA = lengthA64.x;\n  float lenB = lengthB64.x;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\n  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  float isStartCap = step(lenA, 1.0e-5);\n  float isEndCap = step(lenB, 1.0e-5);\n  float isCap = max(isStartCap, isEndCap);\n  cornerPosition = isCap * (1.0 - positions.z);\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L / width;\n  float isEnd = positions.x;\n  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);\n  vec2 dir = mix(dirB, dirA, isEnd);\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);\n  float projected_curr_position_z = project_size(currPosition.z);\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec2 projected_prev_position[2];\n  project_position_fp64(prevPosition.xy, prevPosition64xyLow, projected_prev_position);\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  vec2 projected_next_position[2];\n  project_position_fp64(nextPosition.xy, nextPosition64xyLow, projected_next_position);\n\n  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);\n  vec2 vertex_pos_modelspace[4];\n\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\n}\n",fs:P,modules:["project64","picking"]}:{vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  float relativePosition, bool isEnd, bool isJoint,\n  vec2 width\n) {\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  lenA = lenA > EPSILON ? lenA : 0.0;\n  lenB = lenB > EPSILON ? lenB : 0.0;\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  float cornerPosition = isJoint ?\n    0.0 :\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\n  cornerPosition *=\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\n  if (cornerPosition < 0.0) {\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\n  }\n\n  vMiterLength = cornerPosition >= 0.0 ?\n    mix(offsetScale, 0.0, cornerPosition) :\n    offsetScale * cornerPosition;\n  vMiterLength -= sinHalfA * jointType;\n\n  float offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  bool isStartCap = step(0.0, -lenA) > 0.5;\n  bool isEndCap = step(0.0, -lenB) > 0.5;\n  bool isCap = isStartCap || isEndCap;\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\n  if (isStartCap) {\n    offsetVec = mix(dirB, perpB, cornerPosition);\n  }\n  if (isEndCap) {\n    offsetVec = mix(dirA, perpA, cornerPosition);\n  }\n  if (isCap) {\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\n    vMiterLength = 1.0 - cornerPosition;\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\n  }\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L;\n  vec2 offsetFromStartOfPath = vCornerOffset;\n  if (isEnd) {\n    offsetFromStartOfPath += deltaA;\n  }\n  vec2 dir = isEnd ? dirA : dirB;\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return currPoint + vec3(vCornerOffset * width, 0.0);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float relativePosition = positions.y;\n  bool isEnd = positions.x > EPSILON;\n  bool isJoint = positions.z > EPSILON;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  return lineJoin(\n    prevPoint, currPoint, nextPoint,\n    relativePosition, isEnd, isJoint,\n    billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels)\n  );\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\n    currPosition = project_position(currPosition, currPosition64xyLow);\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\n\n    vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n    gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));\n  }\n}\n",fs:P,modules:["project32","picking"]}}},{key:"initializeState",value:function(){var t=this;this.getAttributeManager().addInstanced({instanceStartPositions:{size:3,transition:x,accessor:"getPath",update:this.calculateStartPositions,noAlloc:!0},instanceEndPositions:{size:3,transition:x,accessor:"getPath",update:this.calculateEndPositions,noAlloc:!0},instanceStartEndPositions64xyLow:{size:4,update:this.calculateInstanceStartEndPositions64xyLow,noAlloc:!0},instanceLeftPositions:{size:3,accessor:"getPath",update:this.calculateLeftPositions,noAlloc:!0},instanceRightPositions:{size:3,accessor:"getPath",update:this.calculateRightPositions,noAlloc:!0},instanceNeighborPositions64xyLow:{size:4,update:this.calculateInstanceNeighborPositions64xyLow,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:x,defaultValue:1},instanceDashArrays:{size:2,accessor:"getDashArray"},instanceColors:{size:4,type:5121,accessor:"getColor",transition:x,defaultValue:y},instancePickingColors:{size:3,type:5121,accessor:function(e,n){var i=n.index,o=n.target;return t.encodePickingColor(i,o)}}}),this.setState({pathTesselator:new g({})})}},{key:"updateState",value:function(t){var n=t.oldProps,i=t.props,o=t.changeFlags;Object(s.a)(Object(a.a)(e.prototype),"updateState",this).call(this,{props:i,oldProps:n,changeFlags:o});var r=this.getAttributeManager();if(o.dataChanged||i.fp64!==n.fp64||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPath)){var c=this.state.pathTesselator;c.updateGeometry({data:i.data,getGeometry:i.getPath,positionFormat:i.positionFormat,fp64:this.use64bitPositions()}),this.setState({numInstances:c.instanceCount,bufferLayout:c.bufferLayout}),r.invalidateAll()}if(i.fp64!==n.fp64){var l=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(l)}),r.invalidateAll()}}},{key:"draw",value:function(t){var e=t.uniforms,n=this.context.viewport,i=this.props,o=i.rounded,r=i.billboard,a=i.miterLimit,s=i.widthUnits,c=i.widthScale,l=i.widthMinPixels,p=i.widthMaxPixels,f=i.dashJustified,u="pixels"===s?n.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},e,{jointType:Number(o),billboard:r,alignMode:Number(f),widthScale:c*u,miterLimit:a,widthMinPixels:l,widthMaxPixels:p})).draw()}},{key:"_getModel",value:function(t){return new p.a(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new f.a({drawMode:4,attributes:{indices:new Uint16Array([0,2,1,1,2,4,1,4,3,3,4,5]),positions:new Float32Array([0,0,1,0,-1,0,0,1,0,1,-1,0,1,1,0,1,0,1])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}},{key:"calculateStartPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("startPositions")}},{key:"calculateEndPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("endPositions")}},{key:"calculateInstanceStartEndPositions64xyLow",value:function(t){var e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("startEndPositions64XyLow"):new Float32Array(4)}},{key:"calculateLeftPositions",value:function(t){var e=this.state.pathTesselator;t.value=e.get("leftPositions")}},{key:"calculateRightPositions",value:function(t){var e=this.state.pathTesselator;t.value=e.get("rightPositions")}},{key:"calculateInstanceNeighborPositions64xyLow",value:function(t){var e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("neighborPositions64XyLow"):new Float32Array(4)}},{key:"clearPickingColor",value:function(t){for(var e=this.decodePickingColor(t),n=this.state.pathTesselator.bufferLayout,i=n[e],o=0,r=0;r<e;r++)o+=n[r];var a=this.getAttributeManager().attributes.instancePickingColors,s=a.value,c=o+i;s.fill(0,3*o,3*c),a.update({value:s})}}]),e}(l.a);b.layerName="PathLayer",b.defaultProps=m},916:function(t,e,n){"use strict";n.r(e),n.d(e,"getLayer",(function(){return u}));var i=n(800),o=n(0),r=n.n(o),a=n(718),s=n(719),c=n(732),l=n(724);function p(){return(p=Object.assign||function(t){for(var e,n=1;n<arguments.length;n++)for(var i in e=arguments[n])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)}function f(t){return t.object.extraProps&&r.a.createElement("div",{className:"deckgl-tooltip"},Object.keys(t.object.extraProps).map((function(e,n){return r.a.createElement(l.a,{key:"prop-"+n,label:e+": ",value:""+t.object.extraProps[e]})})))}function u(t,e,n,o){var r=t,c=r.color_picker,l=[c.r,c.g,c.b,255*c.a],u=e.data.features.map((function(t){return p({},t,{path:t.path,width:r.line_width,color:l})}));r.js_data_mutator&&(u=Object(s.a)(r.js_data_mutator)(u));return new i.a(p({id:"path-layer-"+r.slice_id,getColor:function(t){return t.color},getPath:function(t){return t.path},getWidth:function(t){return t.width},data:u,rounded:!0,widthScale:1},Object(a.a)(r,o,f)))}e.default=Object(c.b)(u,(function(t){var e=[];return t.forEach((function(t){e=e.concat(t.path)})),e}))}}]);