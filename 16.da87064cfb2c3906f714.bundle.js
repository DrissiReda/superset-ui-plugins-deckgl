(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{1037:function(e,t,o){"use strict";o.r(t);var n=o(794),i=o(795),a=o(797),r=o(796),s=o(806),c=o(798),l=o(901),p=o(876),u=o(1198),d=o(1032),g=o(942),h="#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n",f=u.a.fp64LowPart,m=[0,0,0,255],v={fp64:!1,getSourcePosition:{type:"accessor",value:function(e){return e.sourcePosition}},getTargetPosition:{type:"accessor",value:function(e){return e.targetPosition}},getSourceColor:{type:"accessor",value:m},getTargetColor:{type:"accessor",value:m},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0},getStrokeWidth:{deprecatedFor:"getWidth"}},_=function(e){function t(){return Object(n.a)(this,t),Object(a.a)(this,Object(r.a)(t).apply(this,arguments))}return Object(c.a)(t,e),Object(i.a)(t,[{key:"getShaders",value:function(){return this.use64bitProjection()?{vs:"#define SHADER_NAME arc-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\n\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\n\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\nvec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {\n\n  vec2 x[2];\n  vec2_mix_fp64(source, target, ratio, x);\n  vec2 center[2];\n  vec2_mix_fp64(source, target, 0.5, center);\n\n  vec2 dSourceCenter = vec2_distance_fp64(source, center);\n  vec2 dXCenter = vec2_distance_fp64(x, center);\n  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvoid get_pos_fp64(vec2 source[2], vec2 target[2], float segmentRatio, out vec2 position[4]) {\n\n  vec2 vertex_height = paraboloid_fp64(source, target, segmentRatio);\n\n  vec2 position_temp[2];\n\n  vec2_mix_fp64(source, target, segmentRatio, position_temp);\n\n  position[0] = position_temp[0];\n  position[1] = position_temp[1];\n\n  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) {\n    vertex_height = vec2(0.0, 0.0);\n  }\n\n  position[2] = sqrt_fp64(vertex_height);\n  position[3] = vec2(1.0, 0.0);\n}\n\nvoid main(void) {\n  vec2 projected_source_coord[2];\n  vec2 projected_target_coord[2];\n\n  project_position_fp64(instancePositions.xy, instancePositions64Low.xy, projected_source_coord);\n  project_position_fp64(instancePositions.zw, instancePositions64Low.zw, projected_target_coord);\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec2 curr_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, segmentRatio,\n    curr_pos_modelspace);\n\n  vec2 next_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, nextSegmentRatio,\n    next_pos_modelspace);\n\n  vec4 curr_pos_clipspace = project_common_position_to_clipspace_fp64(curr_pos_modelspace);\n  vec4 next_pos_clipspace = project_common_position_to_clipspace_fp64(next_pos_modelspace);\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n\n  vec2 offset = getExtrusionOffset(next_pos_clipspace.xy - curr_pos_clipspace.xy, positions.y, widthPixels);\n\n  gl_Position = curr_pos_clipspace + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n}\n",fs:h,modules:["project64","picking"]}:{vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertexHeight = sqrt(max(0.0, paraboloid(source, target, segmentRatio))) * instanceHeights;\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target - source);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * vertexHeight * sin(tiltAngle);\n\n  return vec3(\n    mix(source, target, segmentRatio) + tilt,\n    vertexHeight * cos(tiltAngle)\n  );\n}\n\nvoid main(void) {\n  vec2 source = project_position(vec3(instancePositions.xy, 0.0), instancePositions64Low.xy).xy;\n  vec2 target = project_position(vec3(instancePositions.zw, 0.0), instancePositions64Low.zw).xy;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec3 currPos = getPos(source, target, segmentRatio);\n  vec3 nextPos = getPos(source, target, nextSegmentRatio);\n  vec4 curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n  vec4 next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels);\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n}\n",fs:h,modules:["picking"]}}},{key:"initializeState",value:function(){this.getAttributeManager().addInstanced({instancePositions:{size:4,transition:!0,accessor:["getSourcePosition","getTargetPosition"],update:this.calculateInstancePositions},instancePositions64Low:{size:4,accessor:["getSourcePosition","getTargetPosition"],update:this.calculateInstancePositions64Low},instanceSourceColors:{size:4,type:5121,transition:!0,accessor:"getSourceColor",defaultValue:m},instanceTargetColors:{size:4,type:5121,transition:!0,accessor:"getTargetColor",defaultValue:m},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}},{key:"updateState",value:function(e){var o=e.props,n=e.oldProps,i=e.changeFlags;if(Object(s.a)(Object(r.a)(t.prototype),"updateState",this).call(this,{props:o,oldProps:n,changeFlags:i}),o.fp64!==n.fp64){var a=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(a)}),this.getAttributeManager().invalidateAll()}}},{key:"draw",value:function(e){var t=e.uniforms,o=this.context.viewport,n=this.props,i=n.widthUnits,a=n.widthScale,r=n.widthMinPixels,s=n.widthMaxPixels,c="pixels"===i?o.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},t,{widthScale:a*c,widthMinPixels:r,widthMaxPixels:s})).draw()}},{key:"_getModel",value:function(e){for(var t=[],o=0;o<50;o++)t=t.concat([o,-1,0,o,1,0]);var n=new d.a(e,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new g.a({drawMode:5,attributes:{positions:new Float32Array(t)}}),isInstanced:!0,shaderCache:this.context.shaderCache}));return n.setUniforms({numSegments:50}),n}},{key:"calculateInstancePositions",value:function(e,t){var o=t.startRow,n=t.endRow,i=this.props,a=i.data,r=i.getSourcePosition,s=i.getTargetPosition,c=e.value,p=o*e.size,u=Object(l.a)(a,o,n),d=u.iterable,g=u.objectInfo,h=!0,f=!1,m=void 0;try{for(var v,_=d[Symbol.iterator]();!(h=(v=_.next()).done);h=!0){var y=v.value;g.index++;var b=r(y,g);c[p++]=b[0],c[p++]=b[1];var x=s(y,g);c[p++]=x[0],c[p++]=x[1]}}catch(e){f=!0,m=e}finally{try{h||null==_.return||_.return()}finally{if(f)throw m}}}},{key:"calculateInstancePositions64Low",value:function(e,t){var o=t.startRow,n=t.endRow,i=this.use64bitPositions();if(e.constant=!i,i){var a=this.props,r=a.data,s=a.getSourcePosition,c=a.getTargetPosition,p=e.value,u=o*e.size,d=Object(l.a)(r,o,n),g=d.iterable,h=d.objectInfo,m=!0,v=!1,_=void 0;try{for(var y,b=g[Symbol.iterator]();!(m=(y=b.next()).done);m=!0){var x=y.value;h.index++;var w=s(x,h);p[u++]=f(w[0]),p[u++]=f(w[1]);var P=c(x,h);p[u++]=f(P[0]),p[u++]=f(P[1])}}catch(e){v=!0,_=e}finally{try{m||null==b.return||b.return()}finally{if(v)throw _}}}else e.value=new Float32Array(4)}}]),t}(p.a);_.layerName="ArcLayer",_.defaultProps=v;var y=o(1),b=o.n(y),x=o(15),w=o(810),P=o(820),C=o(812);function S(){return(S=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e}).apply(this,arguments)}function j(e,t,o,n){const i=t.data.features,a=e.color_picker,r=e.target_color_picker;return new _(S({data:i,getSourceColor:e=>e.sourceColor||e.color||[a.r,a.g,a.b,255*a.a],getTargetColor:e=>e.targetColor||e.color||[r.r,r.g,r.b,255*r.a],id:"path-layer-"+e.slice_id,strokeWidth:e.stroke_width?e.stroke_width:3},Object(w.a)(e,n,(s=e,e=>b.a.createElement("div",{className:"deckgl-tooltip"},b.a.createElement(C.a,{label:Object(x.t)("Start (Longitude, Latitude)")+": ",value:e.object.sourcePosition[0]+", "+e.object.sourcePosition[1]}),b.a.createElement(C.a,{label:Object(x.t)("End (Longitude, Latitude)")+": ",value:e.object.targetPosition[0]+", "+e.object.targetPosition[1]}),s.dimension&&b.a.createElement(C.a,{label:s.dimension+": ",value:""+e.object.cat_color}))))));var s}o.d(t,"getLayer",(function(){return j}));t.default=Object(P.a)(j,(function(e){const t=[];return e.forEach(e=>{t.push(e.sourcePosition),t.push(e.targetPosition)}),t}))},820:function(e,t,o){"use strict";var n=o(1),i=o.n(n),a=o(2),r=o.n(a),s=o(853),c=o(818),l=o(147),p=o(824),u=o(821),d=o(811),g=o(822),h=o(805),f=o(815);function m(){return(m=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e}).apply(this,arguments)}function v(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}const{getScale:_}=l.CategoricalColorNamespace;const y={formData:r.a.object.isRequired,mapboxApiKey:r.a.string.isRequired,setControlValue:r.a.func.isRequired,viewport:r.a.object.isRequired,getLayer:r.a.func.isRequired,getPoints:r.a.func.isRequired,payload:r.a.object.isRequired,onAddFilter:r.a.func,width:r.a.number.isRequired,height:r.a.number.isRequired};class b extends i.a.PureComponent{constructor(e){super(e),v(this,"containerRef",i.a.createRef()),v(this,"setTooltip",e=>{const{current:t}=this.containerRef;t&&t.setTooltip(e)}),this.state=this.getStateFromProps(e),this.getLayers=this.getLayers.bind(this),this.onValuesChange=this.onValuesChange.bind(this),this.toggleCategory=this.toggleCategory.bind(this),this.showSingleCategory=this.showSingleCategory.bind(this)}UNSAFE_componentWillReceiveProps(e){e.payload.form_data!==this.state.formData&&this.setState(m({},this.getStateFromProps(e)))}onValuesChange(e){this.setState({values:Array.isArray(e)?e:[e,e+this.state.getStep(e)]})}getStateFromProps(e,t){const o=e.payload.data.features||[],n=o.map(e=>e.__timestamp),i=function(e,t){const o=e.color_picker||{r:0,g:0,b:0,a:1},n=[o.r,o.g,o.b,255*o.a],i=_(e.color_scheme),a={};return t.forEach(t=>{if(null!=t.cat_color&&!a.hasOwnProperty(t.cat_color)){let r;r=e.dimension?Object(d.hexToRGB)(i(t.cat_color),255*o.a):n,a[t.cat_color]={color:r,enabled:!0}}}),a}(e.formData,o);if(t&&e.payload.form_data===t.formData)return m({},t,{categories:i});const a=e.payload.form_data.time_grain_sqla||e.payload.form_data.granularity||"P1D",{start:r,end:s,getStep:c,values:l,disabled:p}=Object(g.a)(n,a),{width:u,height:h,formData:v}=e;let{viewport:y}=e;return v.autozoom&&(y=Object(f.a)(y,{width:u,height:h,points:e.getPoints(o)})),{start:r,end:s,getStep:c,values:l,disabled:p,viewport:y,selected:[],lastClick:0,formData:e.payload.form_data,categories:i}}getLayers(e){const{getLayer:t,payload:o,formData:n,onAddFilter:i}=this.props;let a=o.data.features?[...o.data.features]:[];if(a=this.addColor(a,n),n.js_data_mutator){a=Object(h.a)(n.js_data_mutator)(a)}a=e[0]===e[1]||e[1]===this.end?a.filter(t=>t.__timestamp>=e[0]&&t.__timestamp<=e[1]):a.filter(t=>t.__timestamp>=e[0]&&t.__timestamp<e[1]);const r=this.state.categories;return n.dimension&&(a=a.filter(e=>r[e.cat_color]&&r[e.cat_color].enabled)),[t(n,m({},o,{data:m({},o.data,{features:a})}),i,this.setTooltip)]}addColor(e,t){const o=t.color_picker||{r:0,g:0,b:0,a:1},n=_(t.color_scheme);return e.map(e=>{let i;return t.dimension?(i=Object(d.hexToRGB)(n(e.cat_color),255*o.a),m({},e,{color:i})):e})}toggleCategory(e){const t=this.state.categories[e],o=m({},this.state.categories,{[e]:m({},t,{enabled:!t.enabled})});Object.values(o).every(e=>!e.enabled)&&Object.values(o).forEach(e=>{e.enabled=!0}),this.setState({categories:o})}showSingleCategory(e){const t=m({},this.state.categories);Object.values(t).forEach(e=>{e.enabled=!1}),t[e].enabled=!0,this.setState({categories:t})}render(){return i.a.createElement("div",{style:{position:"relative"}},i.a.createElement(p.a,{ref:this.containerRef,getLayers:this.getLayers,start:this.state.start,end:this.state.end,getStep:this.state.getStep,values:this.state.values,disabled:this.state.disabled,viewport:this.state.viewport,mapboxApiAccessToken:this.props.mapboxApiKey,mapStyle:this.props.formData.mapbox_style,setControlValue:this.props.setControlValue,width:this.props.width,height:this.props.height},i.a.createElement(u.a,{categories:this.state.categories,toggleCategory:this.toggleCategory,showSingleCategory:this.showSingleCategory,position:this.props.formData.legend_position,format:this.props.formData.legend_format})))}}function x(){return(x=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e}).apply(this,arguments)}function w(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}b.propTypes=y,o.d(t,"b",(function(){return S})),o.d(t,"a",(function(){return j}));const P={formData:r.a.object.isRequired,payload:r.a.object.isRequired,setControlValue:r.a.func.isRequired,viewport:r.a.object.isRequired,onAddFilter:r.a.func,width:r.a.number.isRequired,height:r.a.number.isRequired},C={onAddFilter(){}};function S(e,t){class o extends i.a.PureComponent{constructor(e){super(e),w(this,"containerRef",i.a.createRef()),w(this,"setTooltip",e=>{const{current:t}=this.containerRef;t&&t.setTooltip(e)});const{width:o,height:n,formData:a}=e;let{viewport:r}=e;a.autozoom&&(r=Object(f.a)(r,{width:o,height:n,points:t(e.payload.data.features)})),this.state={viewport:r,layer:this.computeLayer(e)},this.onViewportChange=this.onViewportChange.bind(this)}UNSAFE_componentWillReceiveProps(e){const t=x({},e.formData,{viewport:null}),o=x({},this.props.formData,{viewport:null});Object(s.isEqual)(t,o)&&e.payload===this.props.payload||this.setState({layer:this.computeLayer(e)})}onViewportChange(e){this.setState({viewport:e})}computeLayer(t){const{formData:o,payload:n,onAddFilter:i}=t;return e(o,n,i,this.setTooltip)}render(){const{formData:e,payload:t,setControlValue:o,height:n,width:a}=this.props,{layer:r,viewport:s}=this.state;return i.a.createElement(c.a,{ref:this.containerRef,mapboxApiAccessToken:t.data.mapboxApiKey,viewport:s,layers:[r],mapStyle:e.mapbox_style,setControlValue:o,width:a,height:n,onViewportChange:this.onViewportChange})}}return o.propTypes=P,o.defaultProps=C,o}function j(e,t){function o(o){const{formData:n,payload:a,setControlValue:r,viewport:s,width:c,height:l}=o;return i.a.createElement(b,{formData:n,mapboxApiKey:a.data.mapboxApiKey,setControlValue:r,viewport:s,getLayer:e,payload:a,getPoints:t,width:c,height:l})}return o.propTypes=P,o.defaultProps=C,o}},821:function(e,t,o){"use strict";o.d(t,"a",(function(){return l}));var n=o(1),i=o.n(n),a=o(2),r=o.n(a),s=o(852);o(825);const c={categories:r.a.object,toggleCategory:r.a.func,showSingleCategory:r.a.func,format:r.a.string,position:r.a.oneOf([null,"tl","tr","bl","br"])};class l extends i.a.PureComponent{format(e){if(!this.props.format)return e;const t=parseFloat(e);return Object(s.formatNumber)(this.props.format,t)}formatCategoryLabel(e){if(!this.props.format)return e;if(e.includes(" - ")){const t=e.split(" - ");return this.format(t[0])+" - "+this.format(t[1])}return this.format(e)}render(){if(0===Object.keys(this.props.categories).length||null===this.props.position)return null;const e=Object.entries(this.props.categories).map(e=>{let[t,o]=e;const n={color:"rgba("+o.color.join(", ")+")"},a=o.enabled?"◼":"◻";return i.a.createElement("li",{key:t},i.a.createElement("a",{href:"#",onClick:()=>this.props.toggleCategory(t),onDoubleClick:()=>this.props.showSingleCategory(t)},i.a.createElement("span",{style:n},a)," ",this.formatCategoryLabel(t)))}),t={position:"absolute",["t"===this.props.position.charAt(0)?"top":"bottom"]:"0px",["r"===this.props.position.charAt(1)?"right":"left"]:"10px"};return i.a.createElement("div",{className:"legend",style:t},i.a.createElement("ul",{className:"categories"},e))}}l.propTypes=c,l.defaultProps={categories:{},toggleCategory:()=>{},showSingleCategory:()=>{},format:null,position:"tr"}},825:function(e,t,o){var n=o(371),i=o(826);"string"==typeof(i=i.__esModule?i.default:i)&&(i=[[e.i,i,""]]);var a={insert:"head",singleton:!1},r=(n(i,a),i.locals?i.locals:{});e.exports=r},826:function(e,t,o){(t=o(372)(!1)).push([e.i,'/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\ndiv.legend {\n  font-size: 90%;\n  position: absolute;\n  background: #fff;\n  box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);\n  margin: 24px;\n  padding: 12px 20px;\n  outline: none;\n  overflow-y: scroll;\n  max-height: 200px;\n}\n\nul.categories {\n  list-style: none;\n  padding-left: 0;\n  margin: 0;\n}\n\nul.categories li a {\n  color: rgb(51, 51, 51);\n  text-decoration: none;\n}\n\nul.categories li a span {\n  margin-right: 10px;\n}\n',""]),e.exports=t}}]);