(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{761:function(t,e,n){"use strict";var i=n(0),o=n.n(i),s=n(2),a=n.n(s),r=n(792),c=n(757),l=n(712),p=n(765),f=n(762),d=n(752),h=n(763),u=n(746),g=n(756);function v(){return(v=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}const{getScale:P}=l.a;const y={formData:a.a.object.isRequired,mapboxApiKey:a.a.string.isRequired,setControlValue:a.a.func.isRequired,viewport:a.a.object.isRequired,getLayer:a.a.func.isRequired,getPoints:a.a.func.isRequired,payload:a.a.object.isRequired,onAddFilter:a.a.func,setTooltip:a.a.func,width:a.a.number.isRequired,height:a.a.number.isRequired};class m extends o.a.PureComponent{constructor(t){super(t),this.state=this.getStateFromProps(t),this.getLayers=this.getLayers.bind(this),this.onValuesChange=this.onValuesChange.bind(this),this.toggleCategory=this.toggleCategory.bind(this),this.showSingleCategory=this.showSingleCategory.bind(this)}UNSAFE_componentWillReceiveProps(t){t.payload.form_data!==this.state.formData&&this.setState(v({},this.getStateFromProps(t)))}onValuesChange(t){this.setState({values:Array.isArray(t)?t:[t,t+this.state.getStep(t)]})}getStateFromProps(t,e){const n=t.payload.data.features||[],i=n.map(t=>t.__timestamp),o=function(t,e){const n=t.color_picker||{r:0,g:0,b:0,a:1},i=[n.r,n.g,n.b,255*n.a],o=P(t.color_scheme),s={};return e.forEach(e=>{if(null!=e.cat_color&&!s.hasOwnProperty(e.cat_color)){let a;a=t.dimension?Object(d.hexToRGB)(o(e.cat_color),255*n.a):i,s[e.cat_color]={color:a,enabled:!0}}}),s}(t.formData,n);if(e&&t.payload.form_data===e.formData)return v({},e,{categories:o});const s=t.payload.form_data.time_grain_sqla||t.payload.form_data.granularity||"P1D",{start:a,end:r,getStep:c,values:l,disabled:p}=Object(h.a)(i,s),{width:f,height:u,formData:y}=t;let{viewport:m}=t;return y.autozoom&&(m=Object(g.a)(m,{width:f,height:u,points:t.getPoints(n)})),{start:a,end:r,getStep:c,values:l,disabled:p,viewport:m,selected:[],lastClick:0,formData:t.payload.form_data,categories:o}}getLayers(t){const{getLayer:e,payload:n,formData:i,onAddFilter:o,setTooltip:s}=this.props;let a=n.data.features?[...n.data.features]:[];if(a=this.addColor(a,i),i.js_data_mutator){a=Object(u.a)(i.js_data_mutator)(a)}a=t[0]===t[1]||t[1]===this.end?a.filter(e=>e.__timestamp>=t[0]&&e.__timestamp<=t[1]):a.filter(e=>e.__timestamp>=t[0]&&e.__timestamp<t[1]);const r=this.state.categories;return i.dimension&&(a=a.filter(t=>r[t.cat_color]&&r[t.cat_color].enabled)),[e(i,v({},n,{data:v({},n.data,{features:a})}),o,s)]}addColor(t,e){const n=e.color_picker||{r:0,g:0,b:0,a:1},i=P(e.color_scheme);return t.map(t=>{let o;return e.dimension?(o=Object(d.hexToRGB)(i(t.cat_color),255*n.a),v({},t,{color:o})):t})}toggleCategory(t){const e=this.state.categories[t],n=v({},this.state.categories,{[t]:v({},e,{enabled:!e.enabled})});Object.values(n).every(t=>!t.enabled)&&Object.values(n).forEach(t=>{t.enabled=!0}),this.setState({categories:n})}showSingleCategory(t){const e=v({},this.state.categories);Object.values(e).forEach(t=>{t.enabled=!1}),e[t].enabled=!0,this.setState({categories:e})}render(){return o.a.createElement("div",{style:{position:"relative"}},o.a.createElement(p.a,{getLayers:this.getLayers,start:this.state.start,end:this.state.end,getStep:this.state.getStep,values:this.state.values,disabled:this.state.disabled,viewport:this.state.viewport,mapboxApiAccessToken:this.props.mapboxApiKey,mapStyle:this.props.formData.mapbox_style,setControlValue:this.props.setControlValue,width:this.props.width,height:this.props.height},o.a.createElement(f.a,{categories:this.state.categories,toggleCategory:this.toggleCategory,showSingleCategory:this.showSingleCategory,position:this.props.formData.legend_position,format:this.props.formData.legend_format})))}}function x(){return(x=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}m.propTypes=y,n.d(e,"b",(function(){return _})),n.d(e,"a",(function(){return S}));const b={formData:a.a.object.isRequired,payload:a.a.object.isRequired,setControlValue:a.a.func.isRequired,viewport:a.a.object.isRequired,onAddFilter:a.a.func,setTooltip:a.a.func,width:a.a.number.isRequired,height:a.a.number.isRequired},w={onAddFilter(){},setTooltip(){}};function _(t,e){class n extends o.a.PureComponent{constructor(t){super(t);const{width:n,height:i,formData:o}=t;let{viewport:s}=t;o.autozoom&&(s=Object(g.a)(s,{width:n,height:i,points:e(t.payload.data.features)})),this.state={viewport:s,layer:this.computeLayer(t)},this.onViewportChange=this.onViewportChange.bind(this)}UNSAFE_componentWillReceiveProps(t){const e=x({},t.formData,{viewport:null}),n=x({},this.props.formData,{viewport:null});Object(r.isEqual)(e,n)&&t.payload===this.props.payload||this.setState({layer:this.computeLayer(t)})}onViewportChange(t){this.setState({viewport:t})}computeLayer(e){const{formData:n,payload:i,onAddFilter:o,setTooltip:s}=e;return t(n,i,o,s)}render(){const{formData:t,payload:e,setControlValue:n,height:i,width:s}=this.props,{layer:a,viewport:r}=this.state;return o.a.createElement(c.a,{mapboxApiAccessToken:e.data.mapboxApiKey,viewport:r,layers:[a],mapStyle:t.mapbox_style,setControlValue:n,width:s,height:i,onViewportChange:this.onViewportChange})}}return n.propTypes=b,n.defaultProps=w,n}function S(t,e){function n(n){const{formData:i,payload:s,setControlValue:a,setTooltip:r,viewport:c,width:l,height:p}=n;return o.a.createElement(m,{formData:i,mapboxApiKey:s.data.mapboxApiKey,setControlValue:a,viewport:c,getLayer:t,payload:s,setTooltip:r,getPoints:e,width:l,height:p})}return n.propTypes=b,n.defaultProps=w,n}},762:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var i=n(0),o=n.n(i),s=n(2),a=n.n(s),r=n(1092);n(766);const c={categories:a.a.object,toggleCategory:a.a.func,showSingleCategory:a.a.func,format:a.a.string,position:a.a.oneOf([null,"tl","tr","bl","br"])};class l extends o.a.PureComponent{format(t){if(!this.props.format)return t;const e=parseFloat(t);return Object(r.a)(this.props.format,e)}formatCategoryLabel(t){if(!this.props.format)return t;if(t.includes(" - ")){const e=t.split(" - ");return this.format(e[0])+" - "+this.format(e[1])}return this.format(t)}render(){if(0===Object.keys(this.props.categories).length||null===this.props.position)return null;const t=Object.entries(this.props.categories).map(t=>{let[e,n]=t;const i={color:"rgba("+n.color.join(", ")+")"},s=n.enabled?"◼":"◻";return o.a.createElement("li",{key:e},o.a.createElement("a",{href:"#",onClick:()=>this.props.toggleCategory(e),onDoubleClick:()=>this.props.showSingleCategory(e)},o.a.createElement("span",{style:i},s)," ",this.formatCategoryLabel(e)))}),e={position:"absolute",["t"===this.props.position.charAt(0)?"top":"bottom"]:"0px",["r"===this.props.position.charAt(1)?"right":"left"]:"10px"};return o.a.createElement("div",{className:"legend",style:e},o.a.createElement("ul",{className:"categories"},t))}}l.propTypes=c,l.defaultProps={categories:{},toggleCategory:()=>{},showSingleCategory:()=>{},format:null,position:"tr"}},766:function(t,e,n){var i=n(342),o=n(767);"string"==typeof(o=o.__esModule?o.default:o)&&(o=[[t.i,o,""]]);var s={insert:"head",singleton:!1},a=(i(o,s),o.locals?o.locals:{});t.exports=a},767:function(t,e,n){(e=n(343)(!1)).push([t.i,'/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\ndiv.legend {\n  font-size: 90%;\n  position: absolute;\n  background: #fff;\n  box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);\n  margin: 24px;\n  padding: 12px 20px;\n  outline: none;\n  overflow-y: scroll;\n  max-height: 200px;\n}\n\nul.categories {\n  list-style: none;\n  padding-left: 0;\n  margin: 0;\n}\n\nul.categories li a {\n  color: rgb(51, 51, 51);\n  text-decoration: none;\n}\n\nul.categories li a span {\n  margin-right: 10px;\n}\n',""]),t.exports=e},830:function(t,e,n){"use strict";var i=n(735),o=n(736),s=n(738),a=n(737),r=n(747),c=n(739),l=n(814),p=n(956),f=n(877),d=n(742),h=n(1122),u=d.a.Tesselator,g=h.a.fp64LowPart,v=function(t){function e(t){var n=t.data,o=t.getGeometry,r=t.positionFormat,c=t.fp64;return Object(i.a)(this,e),Object(s.a)(this,Object(a.a)(e).call(this,{data:n,getGeometry:o,fp64:c,positionFormat:r,attributes:{startPositions:{size:3},endPositions:{size:3},leftPositions:{size:3},rightPositions:{size:3},startEndPositions64XyLow:{size:4,fp64Only:!0},neighborPositions64XyLow:{size:4,fp64Only:!0}}}))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"get",value:function(t){return this.attributes[t]}},{key:"getGeometrySize",value:function(t){return Math.max(0,this.getPathLength(t)-1)}},{key:"updateGeometryAttributes",value:function(t,e){var n=this.attributes,i=n.startPositions,o=n.endPositions,s=n.leftPositions,a=n.rightPositions,r=n.startEndPositions64XyLow,c=n.neighborPositions64XyLow,l=this.fp64,p=e.geometrySize+1;if(!(p<2))for(var f,d=this.isClosed(t),h=this.getPointOnPath(t,0),u=this.getPointOnPath(t,1),v=d?this.getPointOnPath(t,p-2):h,P=e.vertexStart,y=1;y<p;P++,y++)f=y+1<p?this.getPointOnPath(t,y+1):d?this.getPointOnPath(t,1):u,i[3*P]=h[0],i[3*P+1]=h[1],i[3*P+2]=h[2]||0,o[3*P]=u[0],o[3*P+1]=u[1],o[3*P+2]=u[2]||0,s[3*P]=v[0],s[3*P+1]=v[1],s[3*P+2]=v[2]||0,a[3*P]=f[0],a[3*P+1]=f[1],a[3*P+2]=f[2]||0,l&&(r[4*P]=g(h[0]),r[4*P+1]=g(h[1]),r[4*P+2]=g(u[0]),r[4*P+3]=g(u[1]),c[4*P]=g(v[0]),c[4*P+1]=g(v[1]),c[4*P+2]=g(f[0]),c[4*P+3]=g(f[1])),v=h,h=u,u=f}},{key:"getPathLength",value:function(t){return Number.isFinite(t[0])?t.length/this.positionSize:t.length}},{key:"getPointOnPath",value:function(t,e){if(Number.isFinite(t[0])){var n=this.positionSize;return[t[e*n],t[e*n+1],3===n?t[e*n+2]:0]}return t[e]}},{key:"isClosed",value:function(t){var e=this.getPathLength(t),n=this.getPointOnPath(t,0),i=this.getPointOnPath(t,e-1);return n[0]===i[0]&&n[1]===i[1]&&n[2]===i[2]}}]),e}(u),P="#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\nuniform float alignMode;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\nbool dash_isFragInGap() {\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = alignMode * solidLength / 2.0;\n\n  return gapLength > 0.0 &&\n    vPathPosition.y >= 0.0 &&\n    vPathPosition.y <= vPathLength &&\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\n}\n\nvoid main(void) {\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\n    discard;\n  }\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";n.d(e,"a",(function(){return b}));var y=[0,0,0,255],m={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},rounded:!1,miterLimit:{type:"number",min:0,value:4},fp64:!1,dashJustified:!1,billboard:!1,getPath:{type:"accessor",value:function(t){return t.path}},getColor:{type:"accessor",value:y},getWidth:{type:"accessor",value:1},getDashArray:{type:"accessor",value:[0,0]}},x={enter:function(t,e){return e.length?e.subarray(e.length-t.length):t}},b=function(t){function e(){return Object(i.a)(this,e),Object(s.a)(this,Object(a.a)(e).apply(this,arguments))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"getShaders",value:function(){return this.use64bitProjection()?{vs:"\n#define SHADER_NAME path-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\nvec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {\n\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n  float width = project_pixel_size(widthPixels);\n\n  vec2 deltaA64[2];\n  vec2 deltaB64[2];\n\n  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);\n  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);\n\n  vec2 lengthA64 = vec2_length_fp64(deltaA64);\n  vec2 lengthB64 = vec2_length_fp64(deltaB64);\n\n  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);\n  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);\n\n  float lenA = lengthA64.x;\n  float lenB = lengthB64.x;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\n  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  float isStartCap = step(lenA, 1.0e-5);\n  float isEndCap = step(lenB, 1.0e-5);\n  float isCap = max(isStartCap, isEndCap);\n  cornerPosition = isCap * (1.0 - positions.z);\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L / width;\n  float isEnd = positions.x;\n  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);\n  vec2 dir = mix(dirB, dirA, isEnd);\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);\n  float projected_curr_position_z = project_size(currPosition.z);\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec2 projected_prev_position[2];\n  project_position_fp64(prevPosition.xy, prevPosition64xyLow, projected_prev_position);\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  vec2 projected_next_position[2];\n  project_position_fp64(nextPosition.xy, nextPosition64xyLow, projected_next_position);\n\n  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);\n  vec2 vertex_pos_modelspace[4];\n\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\n}\n",fs:P,modules:["project64","picking"]}:{vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  float relativePosition, bool isEnd, bool isJoint,\n  vec2 width\n) {\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  lenA = lenA > EPSILON ? lenA : 0.0;\n  lenB = lenB > EPSILON ? lenB : 0.0;\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  float cornerPosition = isJoint ?\n    0.0 :\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\n  cornerPosition *=\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\n  if (cornerPosition < 0.0) {\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\n  }\n\n  vMiterLength = cornerPosition >= 0.0 ?\n    mix(offsetScale, 0.0, cornerPosition) :\n    offsetScale * cornerPosition;\n  vMiterLength -= sinHalfA * jointType;\n\n  float offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  bool isStartCap = step(0.0, -lenA) > 0.5;\n  bool isEndCap = step(0.0, -lenB) > 0.5;\n  bool isCap = isStartCap || isEndCap;\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\n  if (isStartCap) {\n    offsetVec = mix(dirB, perpB, cornerPosition);\n  }\n  if (isEndCap) {\n    offsetVec = mix(dirA, perpA, cornerPosition);\n  }\n  if (isCap) {\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\n    vMiterLength = 1.0 - cornerPosition;\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\n  }\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L;\n  vec2 offsetFromStartOfPath = vCornerOffset;\n  if (isEnd) {\n    offsetFromStartOfPath += deltaA;\n  }\n  vec2 dir = isEnd ? dirA : dirB;\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return currPoint + vec3(vCornerOffset * width, 0.0);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float relativePosition = positions.y;\n  bool isEnd = positions.x > EPSILON;\n  bool isJoint = positions.z > EPSILON;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  return lineJoin(\n    prevPoint, currPoint, nextPoint,\n    relativePosition, isEnd, isJoint,\n    billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels)\n  );\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\n    currPosition = project_position(currPosition, currPosition64xyLow);\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\n\n    vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n    gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));\n  }\n}\n",fs:P,modules:["project32","picking"]}}},{key:"initializeState",value:function(){var t=this;this.getAttributeManager().addInstanced({instanceStartPositions:{size:3,transition:x,accessor:"getPath",update:this.calculateStartPositions,noAlloc:!0},instanceEndPositions:{size:3,transition:x,accessor:"getPath",update:this.calculateEndPositions,noAlloc:!0},instanceStartEndPositions64xyLow:{size:4,update:this.calculateInstanceStartEndPositions64xyLow,noAlloc:!0},instanceLeftPositions:{size:3,accessor:"getPath",update:this.calculateLeftPositions,noAlloc:!0},instanceRightPositions:{size:3,accessor:"getPath",update:this.calculateRightPositions,noAlloc:!0},instanceNeighborPositions64xyLow:{size:4,update:this.calculateInstanceNeighborPositions64xyLow,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:x,defaultValue:1},instanceDashArrays:{size:2,accessor:"getDashArray"},instanceColors:{size:4,type:5121,accessor:"getColor",transition:x,defaultValue:y},instancePickingColors:{size:3,type:5121,accessor:function(e,n){var i=n.index,o=n.target;return t.encodePickingColor(i,o)}}}),this.setState({pathTesselator:new v({})})}},{key:"updateState",value:function(t){var n=t.oldProps,i=t.props,o=t.changeFlags;Object(r.a)(Object(a.a)(e.prototype),"updateState",this).call(this,{props:i,oldProps:n,changeFlags:o});var s=this.getAttributeManager();if(o.dataChanged||i.fp64!==n.fp64||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPath)){var c=this.state.pathTesselator;c.updateGeometry({data:i.data,getGeometry:i.getPath,positionFormat:i.positionFormat,fp64:this.use64bitPositions()}),this.setState({numInstances:c.instanceCount,bufferLayout:c.bufferLayout}),s.invalidateAll()}if(i.fp64!==n.fp64){var l=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(l)}),s.invalidateAll()}}},{key:"draw",value:function(t){var e=t.uniforms,n=this.context.viewport,i=this.props,o=i.rounded,s=i.billboard,a=i.miterLimit,r=i.widthUnits,c=i.widthScale,l=i.widthMinPixels,p=i.widthMaxPixels,f=i.dashJustified,d="pixels"===r?n.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},e,{jointType:Number(o),billboard:s,alignMode:Number(f),widthScale:c*d,miterLimit:a,widthMinPixels:l,widthMaxPixels:p})).draw()}},{key:"_getModel",value:function(t){return new p.a(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new f.a({drawMode:4,attributes:{indices:new Uint16Array([0,2,1,1,2,4,1,4,3,3,4,5]),positions:new Float32Array([0,0,1,0,-1,0,0,1,0,1,-1,0,1,1,0,1,0,1])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}},{key:"calculateStartPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("startPositions")}},{key:"calculateEndPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("endPositions")}},{key:"calculateInstanceStartEndPositions64xyLow",value:function(t){var e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("startEndPositions64XyLow"):new Float32Array(4)}},{key:"calculateLeftPositions",value:function(t){var e=this.state.pathTesselator;t.value=e.get("leftPositions")}},{key:"calculateRightPositions",value:function(t){var e=this.state.pathTesselator;t.value=e.get("rightPositions")}},{key:"calculateInstanceNeighborPositions64xyLow",value:function(t){var e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("neighborPositions64XyLow"):new Float32Array(4)}},{key:"clearPickingColor",value:function(t){for(var e=this.decodePickingColor(t),n=this.state.pathTesselator.bufferLayout,i=n[e],o=0,s=0;s<e;s++)o+=n[s];var a=this.getAttributeManager().attributes.instancePickingColors,r=a.value,c=o+i;r.fill(0,3*o,3*c),a.update({value:r})}}]),e}(l.a);b.layerName="PathLayer",b.defaultProps=m},954:function(t,e,n){"use strict";n.r(e),n.d(e,"getLayer",(function(){return d}));var i=n(830),o=n(0),s=n.n(o),a=n(751),r=n(746),c=n(761),l=n(753);function p(){return(p=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}function f(t){return t.object.extraProps&&s.a.createElement("div",{className:"deckgl-tooltip"},Object.keys(t.object.extraProps).map((e,n)=>s.a.createElement(l.a,{key:"prop-"+n,label:e+": ",value:""+t.object.extraProps[e]})))}function d(t,e,n,o){const s=t,c=s.color_picker,l=[c.r,c.g,c.b,255*c.a];let d=e.data.features.map(t=>p({},t,{path:t.path,width:s.line_width,color:l}));if(s.js_data_mutator){d=Object(r.a)(s.js_data_mutator)(d)}return new i.a(p({id:"path-layer-"+s.slice_id,getColor:t=>t.color,getPath:t=>t.path,getWidth:t=>t.width,data:d,rounded:!0,widthScale:1},Object(a.a)(s,o,f)))}e.default=Object(c.b)(d,(function(t){let e=[];return t.forEach(t=>{e=e.concat(t.path)}),e}))}}]);