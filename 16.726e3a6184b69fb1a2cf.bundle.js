(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{732:function(e,t,o){"use strict";var n=o(0),i=o.n(n),r=o(1),a=o.n(r),s=o(763),c=o(727),l=o(691),p=o(736),u=o(733),d=o(723),g=o(734),f=o(719),h=o(718);function v(){return(v=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var n in t=arguments[o])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)}function m(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}var _=l.a.getScale;var y={formData:a.a.object.isRequired,mapboxApiKey:a.a.string.isRequired,setControlValue:a.a.func.isRequired,viewport:a.a.object.isRequired,getLayer:a.a.func.isRequired,getPoints:a.a.func.isRequired,payload:a.a.object.isRequired,onAddFilter:a.a.func,setTooltip:a.a.func,width:a.a.number.isRequired,height:a.a.number.isRequired},b=function(e){function t(t){var o;return(o=e.call(this,t)||this).state=o.getStateFromProps(t),o.getLayers=o.getLayers.bind(m(o)),o.onValuesChange=o.onValuesChange.bind(m(o)),o.toggleCategory=o.toggleCategory.bind(m(o)),o.showSingleCategory=o.showSingleCategory.bind(m(o)),o}!function(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}(t,e);var o=t.prototype;return o.UNSAFE_componentWillReceiveProps=function(e){e.payload.form_data!==this.state.formData&&this.setState(v({},this.getStateFromProps(e)))},o.onValuesChange=function(e){this.setState({values:Array.isArray(e)?e:[e,e+this.state.getStep(e)]})},o.getStateFromProps=function(e,t){var o=e.payload.data.features||[],n=o.map((function(e){return e.__timestamp})),i=function(e,t){var o=e.color_picker||{r:0,g:0,b:0,a:1},n=[o.r,o.g,o.b,255*o.a],i=_(e.color_scheme),r={};return t.forEach((function(t){var a;null==t.cat_color||r.hasOwnProperty(t.cat_color)||(a=e.dimension?Object(d.hexToRGB)(i(t.cat_color),255*o.a):n,r[t.cat_color]={color:a,enabled:!0})})),r}(e.formData,o);if(t&&e.payload.form_data===t.formData)return v({},t,{categories:i});var r=e.payload.form_data.time_grain_sqla||e.payload.form_data.granularity||"P1D",a=Object(g.a)(n,r);return{start:a.start,end:a.end,getStep:a.getStep,values:a.values,disabled:a.disabled,viewport:e.formData.autozoom?Object(h.b)(e.viewport,e.getPoints(o)):e.viewport,selected:[],lastClick:0,formData:e.payload.form_data,categories:i}},o.getLayers=function(e){var t=this.props,o=t.getLayer,n=t.payload,i=t.formData,r=t.onAddFilter,a=t.setTooltip,s=n.data.features?[].concat(n.data.features):[];(s=this.addColor(s,i),i.js_data_mutator)&&(s=Object(f.a)(i.js_data_mutator)(s));s=e[0]===e[1]||e[1]===this.end?s.filter((function(t){return t.__timestamp>=e[0]&&t.__timestamp<=e[1]})):s.filter((function(t){return t.__timestamp>=e[0]&&t.__timestamp<e[1]}));var c=this.state.categories;return i.dimension&&(s=s.filter((function(e){return c[e.cat_color]&&c[e.cat_color].enabled}))),[o(i,v({},n,{data:v({},n.data,{features:s})}),r,a)]},o.addColor=function(e,t){var o=t.color_picker||{r:0,g:0,b:0,a:1},n=_(t.color_scheme);return e.map((function(e){return t.dimension?v({},e,{color:Object(d.hexToRGB)(n(e.cat_color),255*o.a)}):e}))},o.toggleCategory=function(e){var t,o=this.state.categories[e],n=v({},this.state.categories,((t={})[e]=v({},o,{enabled:!o.enabled}),t));Object.values(n).every((function(e){return!e.enabled}))&&Object.values(n).forEach((function(e){e.enabled=!0})),this.setState({categories:n})},o.showSingleCategory=function(e){var t=v({},this.state.categories);Object.values(t).forEach((function(e){e.enabled=!1})),t[e].enabled=!0,this.setState({categories:t})},o.render=function(){return i.a.createElement("div",{style:{position:"relative"}},i.a.createElement(p.a,{getLayers:this.getLayers,start:this.state.start,end:this.state.end,getStep:this.state.getStep,values:this.state.values,onValuesChange:this.onValuesChange,disabled:this.state.disabled,viewport:this.state.viewport,mapboxApiAccessToken:this.props.mapboxApiKey,mapStyle:this.props.formData.mapbox_style,setControlValue:this.props.setControlValue,width:this.props.width,height:this.props.height},i.a.createElement(u.a,{categories:this.state.categories,toggleCategory:this.toggleCategory,showSingleCategory:this.showSingleCategory,position:this.props.formData.legend_position,format:this.props.formData.legend_format})))},t}(i.a.PureComponent);function x(){return(x=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var n in t=arguments[o])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)}b.propTypes=y,o.d(t,"b",(function(){return P})),o.d(t,"a",(function(){return S}));var w={formData:a.a.object.isRequired,payload:a.a.object.isRequired,setControlValue:a.a.func.isRequired,viewport:a.a.object.isRequired,onAddFilter:a.a.func,setTooltip:a.a.func,width:a.a.number.isRequired,height:a.a.number.isRequired},C={onAddFilter:function(){},setTooltip:function(){}};function P(e,t){var o=function(o){function n(e){var n=o.call(this,e)||this,i=e.viewport,r=e.formData.autozoom?Object(h.b)(i,t(e.payload.data.features)):i;return n.state={viewport:r,layer:n.computeLayer(e)},n.onViewportChange=n.onViewportChange.bind(function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(n)),n}!function(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}(n,o);var r=n.prototype;return r.UNSAFE_componentWillReceiveProps=function(e){var t=x({},e.formData,{viewport:null}),o=x({},this.props.formData,{viewport:null});Object(s.isEqual)(t,o)&&e.payload===this.props.payload||this.setState({layer:this.computeLayer(e)})},r.onViewportChange=function(e){this.setState({viewport:e})},r.computeLayer=function(t){var o=t.formData,n=t.payload,i=t.onAddFilter,r=t.setTooltip;return e(o,n,i,r)},r.render=function(){var e=this.props,t=e.formData,o=e.payload,n=e.setControlValue,r=e.height,a=e.width,s=this.state,l=s.layer,p=s.viewport;return i.a.createElement(c.a,{mapboxApiAccessToken:o.data.mapboxApiKey,viewport:p,layers:[l],mapStyle:t.mapbox_style,setControlValue:n,onViewportChange:this.onViewportChange,width:a,height:r})},n}(i.a.PureComponent);return o.propTypes=w,o.defaultProps=C,o}function S(e,t){function o(o){var n=o.formData,r=o.payload,a=o.setControlValue,s=o.onAddFilter,c=o.setTooltip,l=o.viewport,p=o.width,u=o.height;return i.a.createElement(b,{formData:n,mapboxApiKey:r.data.mapboxApiKey,setControlValue:a,viewport:l,getLayer:e,payload:r,onAddFilter:s,setTooltip:c,getPoints:t,width:p,height:u})}return o.propTypes=w,o.defaultProps=C,o}},733:function(e,t,o){"use strict";o.d(t,"a",(function(){return l}));var n=o(0),i=o.n(n),r=o(1),a=o.n(r),s=o(1045);o(737);var c={categories:a.a.object,toggleCategory:a.a.func,showSingleCategory:a.a.func,format:a.a.string,position:a.a.oneOf([null,"tl","tr","bl","br"])},l=function(e){function t(){return e.apply(this,arguments)||this}!function(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}(t,e);var o=t.prototype;return o.format=function(e){if(!this.props.format)return e;var t=parseFloat(e);return Object(s.a)(this.props.format,t)},o.formatCategoryLabel=function(e){if(!this.props.format)return e;if(e.includes(" - ")){var t=e.split(" - ");return this.format(t[0])+" - "+this.format(t[1])}return this.format(e)},o.render=function(){var e,t=this;if(0===Object.keys(this.props.categories).length||null===this.props.position)return null;var o=Object.entries(this.props.categories).map((function(e){var o=e[0],n=e[1],r={color:"rgba("+n.color.join(", ")+")"},a=n.enabled?"◼":"◻";return i.a.createElement("li",{key:o},i.a.createElement("a",{href:"#",onClick:function(){return t.props.toggleCategory(o)},onDoubleClick:function(){return t.props.showSingleCategory(o)}},i.a.createElement("span",{style:r},a)," ",t.formatCategoryLabel(o)))})),n="t"===this.props.position.charAt(0)?"top":"bottom",r="r"===this.props.position.charAt(1)?"right":"left",a=((e={position:"absolute"})[n]="0px",e[r]="10px",e);return i.a.createElement("div",{className:"legend",style:a},i.a.createElement("ul",{className:"categories"},o))},t}(i.a.PureComponent);l.propTypes=c,l.defaultProps={categories:{},toggleCategory:function(){},showSingleCategory:function(){},format:null,position:"tr"}},737:function(e,t,o){var n=o(738);"string"==typeof n&&(n=[[e.i,n,""]]);var i={hmr:!0,transform:void 0,insertInto:void 0};o(341)(n,i);n.locals&&(e.exports=n.locals)},738:function(e,t,o){(e.exports=o(340)(!1)).push([e.i,'/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\ndiv.legend {\n    font-size: 90%;\n    position: absolute;\n    background: #fff;\n    box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);\n    margin: 24px;\n    padding: 12px 20px;\n    outline: none;\n    overflow-y: scroll;\n    max-height: 200px;\n}\n\nul.categories {\n    list-style: none;\n    padding-left: 0;\n    margin: 0;\n}\n\nul.categories li a {\n    color: rgb(51, 51, 51);\n    text-decoration: none;\n}\n\nul.categories li a span {\n    margin-right: 10px;\n}\n',""])},923:function(e,t,o){"use strict";o.r(t);var n=o(709),i=o(710),r=o(711),a=o(211),s=o(720),c=o(712),l=o(808),p=o(784),u=o(1074),d=o(919),g=o(846),f="#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n",h=u.a.fp64LowPart,v=[0,0,0,255],m={fp64:!1,getSourcePosition:{type:"accessor",value:function(e){return e.sourcePosition}},getTargetPosition:{type:"accessor",value:function(e){return e.targetPosition}},getSourceColor:{type:"accessor",value:v},getTargetColor:{type:"accessor",value:v},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0},getStrokeWidth:{deprecatedFor:"getWidth"}},_=function(e){function t(){return Object(n.a)(this,t),Object(r.a)(this,Object(a.a)(t).apply(this,arguments))}return Object(c.a)(t,e),Object(i.a)(t,[{key:"getShaders",value:function(){return this.use64bitProjection()?{vs:"#define SHADER_NAME arc-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\n\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\n\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\nvec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {\n\n  vec2 x[2];\n  vec2_mix_fp64(source, target, ratio, x);\n  vec2 center[2];\n  vec2_mix_fp64(source, target, 0.5, center);\n\n  vec2 dSourceCenter = vec2_distance_fp64(source, center);\n  vec2 dXCenter = vec2_distance_fp64(x, center);\n  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvoid get_pos_fp64(vec2 source[2], vec2 target[2], float segmentRatio, out vec2 position[4]) {\n\n  vec2 vertex_height = paraboloid_fp64(source, target, segmentRatio);\n\n  vec2 position_temp[2];\n\n  vec2_mix_fp64(source, target, segmentRatio, position_temp);\n\n  position[0] = position_temp[0];\n  position[1] = position_temp[1];\n\n  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) {\n    vertex_height = vec2(0.0, 0.0);\n  }\n\n  position[2] = sqrt_fp64(vertex_height);\n  position[3] = vec2(1.0, 0.0);\n}\n\nvoid main(void) {\n  vec2 projected_source_coord[2];\n  vec2 projected_target_coord[2];\n\n  project_position_fp64(instancePositions.xy, instancePositions64Low.xy, projected_source_coord);\n  project_position_fp64(instancePositions.zw, instancePositions64Low.zw, projected_target_coord);\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec2 curr_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, segmentRatio,\n    curr_pos_modelspace);\n\n  vec2 next_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, nextSegmentRatio,\n    next_pos_modelspace);\n\n  vec4 curr_pos_clipspace = project_common_position_to_clipspace_fp64(curr_pos_modelspace);\n  vec4 next_pos_clipspace = project_common_position_to_clipspace_fp64(next_pos_modelspace);\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n\n  vec2 offset = getExtrusionOffset(next_pos_clipspace.xy - curr_pos_clipspace.xy, positions.y, widthPixels);\n\n  gl_Position = curr_pos_clipspace + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n}\n",fs:f,modules:["project64","picking"]}:{vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertexHeight = sqrt(max(0.0, paraboloid(source, target, segmentRatio))) * instanceHeights;\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target - source);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * vertexHeight * sin(tiltAngle);\n\n  return vec3(\n    mix(source, target, segmentRatio) + tilt,\n    vertexHeight * cos(tiltAngle)\n  );\n}\n\nvoid main(void) {\n  vec2 source = project_position(vec3(instancePositions.xy, 0.0), instancePositions64Low.xy).xy;\n  vec2 target = project_position(vec3(instancePositions.zw, 0.0), instancePositions64Low.zw).xy;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec3 currPos = getPos(source, target, segmentRatio);\n  vec3 nextPos = getPos(source, target, nextSegmentRatio);\n  vec4 curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n  vec4 next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels);\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n}\n",fs:f,modules:["picking"]}}},{key:"initializeState",value:function(){this.getAttributeManager().addInstanced({instancePositions:{size:4,transition:!0,accessor:["getSourcePosition","getTargetPosition"],update:this.calculateInstancePositions},instancePositions64Low:{size:4,accessor:["getSourcePosition","getTargetPosition"],update:this.calculateInstancePositions64Low},instanceSourceColors:{size:4,type:5121,transition:!0,accessor:"getSourceColor",defaultValue:v},instanceTargetColors:{size:4,type:5121,transition:!0,accessor:"getTargetColor",defaultValue:v},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}},{key:"updateState",value:function(e){var o=e.props,n=e.oldProps,i=e.changeFlags;if(Object(s.a)(Object(a.a)(t.prototype),"updateState",this).call(this,{props:o,oldProps:n,changeFlags:i}),o.fp64!==n.fp64){var r=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(r)}),this.getAttributeManager().invalidateAll()}}},{key:"draw",value:function(e){var t=e.uniforms,o=this.context.viewport,n=this.props,i=n.widthUnits,r=n.widthScale,a=n.widthMinPixels,s=n.widthMaxPixels,c="pixels"===i?o.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},t,{widthScale:r*c,widthMinPixels:a,widthMaxPixels:s})).draw()}},{key:"_getModel",value:function(e){for(var t=[],o=0;o<50;o++)t=t.concat([o,-1,0,o,1,0]);var n=new d.a(e,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new g.a({drawMode:5,attributes:{positions:new Float32Array(t)}}),isInstanced:!0,shaderCache:this.context.shaderCache}));return n.setUniforms({numSegments:50}),n}},{key:"calculateInstancePositions",value:function(e,t){var o=t.startRow,n=t.endRow,i=this.props,r=i.data,a=i.getSourcePosition,s=i.getTargetPosition,c=e.value,p=o*e.size,u=Object(l.a)(r,o,n),d=u.iterable,g=u.objectInfo,f=!0,h=!1,v=void 0;try{for(var m,_=d[Symbol.iterator]();!(f=(m=_.next()).done);f=!0){var y=m.value;g.index++;var b=a(y,g);c[p++]=b[0],c[p++]=b[1];var x=s(y,g);c[p++]=x[0],c[p++]=x[1]}}catch(e){h=!0,v=e}finally{try{f||null==_.return||_.return()}finally{if(h)throw v}}}},{key:"calculateInstancePositions64Low",value:function(e,t){var o=t.startRow,n=t.endRow,i=this.use64bitPositions();if(e.constant=!i,i){var r=this.props,a=r.data,s=r.getSourcePosition,c=r.getTargetPosition,p=e.value,u=o*e.size,d=Object(l.a)(a,o,n),g=d.iterable,f=d.objectInfo,v=!0,m=!1,_=void 0;try{for(var y,b=g[Symbol.iterator]();!(v=(y=b.next()).done);v=!0){var x=y.value;f.index++;var w=s(x,f);p[u++]=h(w[0]),p[u++]=h(w[1]);var C=c(x,f);p[u++]=h(C[0]),p[u++]=h(C[1])}}catch(e){m=!0,_=e}finally{try{v||null==b.return||b.return()}finally{if(m)throw _}}}else e.value=new Float32Array(4)}}]),t}(p.a);_.layerName="ArcLayer",_.defaultProps=m;var y=o(0),b=o.n(y),x=o(690),w=o(718),C=o(732),P=o(724);function S(){return(S=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var n in t=arguments[o])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)}function j(e,t,o,n){var i=t.data.features,r=e.color_picker,a=e.target_color_picker;return new _(S({data:i,getSourceColor:function(e){return e.sourceColor||e.color||[r.r,r.g,r.b,255*r.a]},getTargetColor:function(e){return e.targetColor||e.color||[a.r,a.g,a.b,255*a.a]},id:"path-layer-"+e.slice_id,strokeWidth:e.stroke_width?e.stroke_width:3},Object(w.a)(e,n,function(e){return function(t){return b.a.createElement("div",{className:"deckgl-tooltip"},b.a.createElement(P.a,{label:Object(x.b)("Start (Longitude, Latitude)")+": ",value:t.object.sourcePosition[0]+", "+t.object.sourcePosition[1]}),b.a.createElement(P.a,{label:Object(x.b)("End (Longitude, Latitude)")+": ",value:t.object.targetPosition[0]+", "+t.object.targetPosition[1]}),e.dimension&&b.a.createElement(P.a,{label:e.dimension+": ",value:""+t.object.cat_color}))}}(e))))}o.d(t,"getLayer",(function(){return j}));t.default=Object(C.a)(j,(function(e){var t=[];return e.forEach((function(e){t.push(e.sourcePosition),t.push(e.targetPosition)})),t}))}}]);