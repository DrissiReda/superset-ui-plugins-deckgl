(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{955:function(e,t,a){"use strict";a.d(t,"a",(function(){return X}));var i,n=a(900),r=a(903),o=a(894),s=a(895),g=a(1250),u=a(1235),l=a(1236),c=a(1149),d=a(949),f=a(1227),h=a(1093),v=a(1248),m=a(1238),p=a(917),x=a(1009),M=a(929),w={dataChanged:!0,viewportChanged:!0,cellSizeChanged:!0},b={changeFlags:w,projectPoints:!1,useGPU:!0,fp64:!1,viewport:null,gridTransformMatrix:null,createBufferObjects:!0},y=3402823466e29,A=[32775,32774],C=[32776,32774],P=[32776,32775],S=(i={},Object(n.a)(i,M.a.SUM,32774),Object(n.a)(i,M.a.MEAN,32774),Object(n.a)(i,M.a.MIN,A),Object(n.a)(i,M.a.MAX,C),i),j={size:1,operation:M.a.SUM,needMin:!1,needMax:!1,combineMaxMin:!1},z=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],T="#define SHADER_NAME gpu-aggregation-to-grid-vs\n\nattribute vec2 positions;\nattribute vec3 weights;\nuniform vec2 windowSize;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform mat4 uProjectionMatrix;\nuniform bool projectPoints;\n\nvarying vec3 vWeights;\n\nvec2 project_to_pixel(vec4 pos) {\n  vec4 result =  uProjectionMatrix * pos;\n  return result.xy/result.w;\n}\n\nvoid main(void) {\n\n  vWeights = weights;\n\n  vec4 windowPos = vec4(positions, 0, 1.);\n  if (projectPoints) {\n    windowPos = project_position_to_clipspace(vec3(positions, 0), vec2(0, 0), vec3(0, 0, 0));\n  }\n\n  vec2 pos = project_to_pixel(windowPos);\n  pos = floor(pos / cellSize);\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",F="#define SHADER_NAME gpu-aggregation-to-grid-vs-64\n\nattribute vec2 positions;\nattribute vec2 positions64xyLow;\nattribute vec3 weights;\nuniform vec2 windowSize;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform vec2 uProjectionMatrixFP64[16];\nuniform bool projectPoints;\n\nvarying vec3 vWeights;\n\nvoid project_to_pixel(vec2 pos, vec2 pos64xyLow, out vec2 pixelXY64[2]) {\n\n  vec2 result64[4];\n  vec2 position64[4];\n  position64[0] = vec2(pos.x, pos64xyLow.x);\n  position64[1] = vec2(pos.y, pos64xyLow.y);\n  position64[2] = vec2(0., 0.);\n  position64[3] = vec2(1., 0.);\n  mat4_vec4_mul_fp64(uProjectionMatrixFP64, position64,\n  result64);\n\n  pixelXY64[0] = div_fp64(result64[0], result64[3]);\n  pixelXY64[1] = div_fp64(result64[1], result64[3]);\n}\n\nvoid main(void) {\n\n  vWeights = weights;\n\n  vec2 windowPos = positions;\n  vec2 windowPos64xyLow = positions64xyLow;\n  if (projectPoints) {\n    vec2 projectedXY[2];\n    project_position_fp64(windowPos, windowPos64xyLow, projectedXY);\n    windowPos.x = projectedXY[0].x;\n    windowPos.y = projectedXY[1].x;\n    windowPos64xyLow.x = projectedXY[0].y;\n    windowPos64xyLow.y = projectedXY[1].y;\n  }\n\n  vec2 pixelXY64[2];\n  project_to_pixel(windowPos, windowPos64xyLow, pixelXY64);\n  vec2 gridXY64[2];\n  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\n  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\n  float x = floor(gridXY64[0].x);\n  float y = floor(gridXY64[1].x);\n  vec2 pos = vec2(x, y);\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",D="#define SHADER_NAME gpu-aggregation-to-grid-fs\n\nprecision highp float;\n\nvarying vec3 vWeights;\n\nvoid main(void) {\n  gl_FragColor = vec4(vWeights, 1.0);\n}\n",O=a(1040),_=a(970);function B(e,t){var a,i=t.width,r=void 0===i?1:i,o=t.height,s=void 0===o?1:o;return new O.a(e,{data:null,format:34836,type:5126,border:0,mipmaps:!1,parameters:(a={},Object(n.a)(a,10240,9728),Object(n.a)(a,10241,9728),a),dataFormat:6408,width:r,height:s})}function k(e,t){var a=t.id,i=t.width,r=void 0===i?1:i,o=t.height,s=void 0===o?1:o,g=t.texture;return new _.a(e,{id:a,width:r,height:s,attachments:Object(n.a)({},36064,g)})}function E(e,t){var a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return!e||e.length<t?new Float32Array(t).fill(a):e}var U=g.a.fp64ifyMatrix4,R=["aggregationBuffer","maxMinBuffer","minBuffer","maxBuffer"],I={maxData:"maxBuffer",minData:"minBuffer",maxMinData:"maxMinBuffer"},X=function(){function e(t){var a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Object(o.a)(this,e),this.id=a.id||"gpu-grid-aggregator",this.shaderCache=a.shaderCache||null,this.gl=t,this.state={weights:null,gridPositions:null,positionsBuffer:null,positions64xyLowBuffer:null,vertexCount:0,fp64:null,useGPU:null,numCol:0,numRow:0,windowSize:null,cellSize:null,weightAttributes:{},textures:{},meanTextures:{},buffers:{},framebuffers:{},maxMinFramebuffers:{},minFramebuffers:{},maxFramebuffers:{},equations:{},resources:{},results:{}},this._hasGPUSupport=Object(u.d)(t)&&Object(l.c)(this.gl,c.a.BLEND_EQUATION_MINMAX,c.a.COLOR_ATTACHMENT_RGBA32F,c.a.TEXTURE_FLOAT)}return Object(s.a)(e,null,[{key:"getAggregationData",value:function(e){var t=e.aggregationData,a=e.maxData,i=e.minData,n=e.maxMinData,r=4*e.pixelIndex,o={};return t&&(o.cellCount=t[r+3],o.cellWeight=t[r]),n?(o.maxCellWieght=n[0],o.minCellWeight=n[3]):(a&&(o.maxCellWieght=a[0],o.totalCount=a[3]),i&&(o.minCellWeight=i[0],o.totalCount=a[3])),o}},{key:"getCellData",value:function(e){for(var t=e.countsData,a=e.size,i=void 0===a?1:a,n=t.length/4,r=new Float32Array(n*i),o=new Uint32Array(n),s=0;s<n;s++){for(var g=0;g<i;g++)r[s*i+g]=t[4*s+g];o[s]=t[4*s+3]}return{cellCounts:o,cellWeights:r}}},{key:"isSupported",value:function(e){return Object(u.d)(e)&&Object(l.c)(e,c.a.BLEND_EQUATION_MINMAX,c.a.COLOR_ATTACHMENT_RGBA32F,c.a.TEXTURE_FLOAT)}}]),Object(s.a)(e,[{key:"delete",value:function(){var e=this.gridAggregationModel,t=this.allAggregationModel,a=this.meanTransform,i=this.state,n=i.positionsBuffer,r=i.positions64xyLowBuffer,o=i.textures,s=i.framebuffers,g=i.maxMinFramebuffers,u=i.minFramebuffers,l=i.maxFramebuffers,c=i.meanTextures,d=i.resources;e&&e.delete(),t&&t.delete(),a&&a.delete(),n&&n.delete(),r&&r.delete(),this.deleteResources([s,o,g,u,l,c,d])}},{key:"run",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.setState({results:{}});var t=this.getAggregationParams(e);this.updateGridSize(t);var a=t.useGPU;return this._hasGPUSupport&&a?this.runAggregationOnGPU(t):(a&&p.a.info("GPUGridAggregator: GPU Aggregation not supported, falling back to CPU")(),this.runAggregationOnCPU(t))}},{key:"getData",value:function(e){var t={},a=this.state.results;for(var i in a[e].aggregationData||(a[e].aggregationData=a[e].aggregationBuffer.getData()),t.aggregationData=a[e].aggregationData,I){var n=I[i];(a[e][i]||a[e][n])&&(a[e][i]=a[e][i]||a[e][n].getData(),t[i]=a[e][i])}return t}},{key:"deleteResources",value:function(e){(e=Array.isArray(e)?e:[e]).forEach((function(e){for(var t in e)e[t].delete()}))}},{key:"getAggregationParams",value:function(e){var t=Object.assign({},b,e),a=t.useGPU,i=t.gridTransformMatrix,n=t.viewport,r=t.weights,o=t.projectPoints,s=t.cellSize;return this.state.useGPU!==a&&(t.changeFlags=Object.assign({},t.changeFlags,w)),!s||this.state.cellSize&&this.state.cellSize[0]===s[0]&&this.state.cellSize[1]===s[1]||(t.changeFlags.cellSizeChanged=!0,this.setState({cellSize:s})),this.validateProps(t,e),this.setState({useGPU:a}),t.gridTransformMatrix=(o?n.viewportMatrix:i)||z,r&&(t.weights=this.normalizeWeightParams(r),this.setState({weights:t.weights})),t}},{key:"normalizeWeightParams",value:function(e){var t={};for(var a in e)t[a]=Object.assign({},j,e[a]);return t}},{key:"setState",value:function(e){Object.assign(this.state,e)}},{key:"shouldTransformToGrid",value:function(e){var t=e.projectPoints,a=e.changeFlags;return!!(!this.state.gridPositions||a.dataChanged||t&&a.viewportChanged)}},{key:"updateGridSize",value:function(e){var t=e.viewport,a=e.cellSize,i=e.width||t.width,n=e.height||t.height,r=Math.ceil(i/a[0]),o=Math.ceil(n/a[1]);this.setState({numCol:r,numRow:o,windowSize:[i,n]})}},{key:"validateProps",value:function(e,t){var a=e.changeFlags,i=e.projectPoints,n=e.gridTransformMatrix;p.a.assert(a.dataChanged||a.viewportChanged||a.cellSizeChanged),p.a.assert(!a.dataChanged||t.positions&&t.weights&&(!t.projectPositions||t.viewport)&&t.cellSize),p.a.assert(!a.cellSizeChanged||t.cellSize),p.a.assert(!(a.viewportChanged&&i)||t.viewport),i&&n&&p.a.warn("projectPoints is true, gridTransformMatrix is ignored")()}},{key:"calculateAggregationData",value:function(e){var t=e.weights,a=e.results,i=e.cellIndex,n=e.posIndex;for(var r in t){for(var o=t[r],s=o.values,g=o.size,u=o.operation,l=a[r].aggregationData,c=0;c<g;c++){var d=i+c,f=s[3*n+c];if(0===l[i+3])l[d]=f;else switch(u){case M.a.SUM:case M.a.MEAN:l[d]+=f;break;case M.a.MIN:l[d]=Math.min(l[d],f);break;case M.a.MAX:l[d]=Math.max(l[d],f);break;default:p.a.assert(!1)}}l[i+3]++}}},{key:"calculateMeanMaxMinData",value:function(e){var t=e.validCellIndices,a=e.results,i=e.weights;t.forEach((function(e){for(var t in a){for(var n=i[t],r=n.size,o=n.needMin,s=n.needMax,g=n.operation,u=a[t],l=u.aggregationData,c=u.minData,d=u.maxData,f=u.maxMinData,h=o||s,v=g===M.a.MEAN,m=o&&s&&i[t].combineMaxMin,p=l[e+4-1],x=0;x<r&&(h||v);x++){var w=e+x,b=l[w];v&&(l[w]/=p,b=l[w]),m?f[x]=Math.max(f[x],b):(o&&(c[x]=Math.min(c[x],b)),s&&(d[x]=Math.max(d[x],b)))}m?f[3]=Math.min(f[3],l[e+0]):(o&&(c[3]+=p),s&&(d[3]+=p))}}))}},{key:"initCPUResults",value:function(e){var t=e.weights||this.state.weights,a=this.state,i=a.numCol,n=a.numRow,r={};for(var o in t){var s=t[o],g=s.aggregationData,u=s.minData,l=s.maxData,c=s.maxMinData,d=t[o],f=d.needMin,h=d.needMax,v=f&&h&&t[o].combineMaxMin;g=E(g,i*n*4),v?((c=E(c,4)).fill(-1/0,0,3),c[3]=1/0):(f&&((u=E(u,4,1/0))[3]=0),h&&((l=E(l,4,-1/0))[3]=0)),r[o]=Object.assign({},t[o],{aggregationData:g,minData:u,maxData:l,maxMinData:c})}return r}},{key:"runAggregationOnCPU",value:function(e){var t,a,i=e.positions,n=e.cellSize,o=e.gridTransformMatrix,s=e.viewport,g=e.projectPoints,u=e.weights,l=this.state,c=l.numCol,d=l.numRow,f=this.initCPUResults(e),h=this.shouldTransformToGrid(e),v=[0,0,0];p.a.assert(h||e.changeFlags.cellSizeChanged),h?(a=i.length/2,t=new Float64Array(i.length),this.setState({gridPositions:t})):(t=this.state.gridPositions,u=this.state.weights,a=t.length/2);for(var m=new Set,M=0;M<a;M++){var w=void 0,b=void 0;if(h){if(v[0]=i[2*M],v[1]=i[2*M+1],g){var y=s.project(v),A=Object(r.a)(y,2);w=A[0],b=A[1]}else{var C=Object(x.k)(v,o),P=Object(r.a)(C,2);w=P[0],b=P[1]}t[2*M]=w,t[2*M+1]=b}else w=t[2*M],b=t[2*M+1];var S=Math.floor(w/n[0]),j=Math.floor(b/n[1]);if(S>=0&&S<c&&j>=0&&j<d){var z=4*(S+j*c);m.add(z),this.calculateAggregationData({weights:u,results:f,cellIndex:z,posIndex:M})}}return this.calculateMeanMaxMinData({validCellIndices:m,results:f,weights:u}),this.updateAggregationBuffers(e,f),this.setState({results:f}),f}},{key:"updateCPUResultBuffer",value:function(e){var t=e.gl,a=e.bufferName,i=e.id,n=e.data,r=e.result,o=this.state.resources,s="cpu-result-".concat(i,"-").concat(a);r[a]=r[a]||o[s],r[a]?r[a].setData({data:n}):(o[s]=new d.a(t,n),r[a]=o[s])}},{key:"updateAggregationBuffers",value:function(e,t){if(e.createBufferObjects){var a=e.weights||this.state.weights;for(var i in t){var n=t[i],r=n.aggregationData,o=n.minData,s=n.maxData,g=n.maxMinData,u=a[i],l=u.needMin,c=u.needMax,d=l&&c&&a[i].combineMaxMin;this.updateCPUResultBuffer({gl:this.gl,bufferName:"aggregationBuffer",id:i,data:r,result:t[i]}),d?this.updateCPUResultBuffer({gl:this.gl,bufferName:"maxMinBuffer",id:i,data:g,result:t[i]}):(l&&this.updateCPUResultBuffer({gl:this.gl,bufferName:"minBuffer",id:i,data:o,result:t[i]}),c&&this.updateCPUResultBuffer({gl:this.gl,bufferName:"maxBuffer",id:i,data:s,result:t[i]}))}}}},{key:"getAggregateData",value:function(e){var t={},a=this.state,i=a.textures,n=a.framebuffers,r=a.maxMinFramebuffers,o=a.minFramebuffers,s=a.maxFramebuffers,g=a.weights;for(var u in g){t[u]={};var l=g[u],c=l.needMin,d=l.needMax,h=l.combineMaxMin;t[u].aggregationTexture=i[u],t[u].aggregationBuffer=Object(f.c)(n[u],{target:g[u].aggregationBuffer,sourceType:5126}),c&&d&&h?t[u].maxMinBuffer=Object(f.c)(r[u],{target:g[u].maxMinBuffer,sourceType:5126}):(c&&(t[u].minBuffer=Object(f.c)(o[u],{target:g[u].minBuffer,sourceType:5126})),d&&(t[u].maxBuffer=Object(f.c)(s[u],{target:g[u].maxBuffer,sourceType:5126})))}return this.trackGPUResultBuffers(t,g),t}},{key:"getAggregationModel",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=this.gl,a=this.shaderCache;return new h.a(t,{id:"Gird-Aggregation-Model",vs:e?F:T,fs:D,modules:e?["fp64","project64"]:["project32"],shaderCache:a,vertexCount:0,drawMode:0})}},{key:"getAllAggregationModel",value:function(){var e=this.gl,t=this.shaderCache,a=this.state,i=a.numCol,n=a.numRow;return new h.a(e,{id:"All-Aggregation-Model",vs:"#version 300 es\n#define SHADER_NAME gpu-aggregation-all-vs-64\n\nin vec2 position;\nuniform ivec2 gridSize;\nout vec2 vTextureCoord;\n\nvoid main(void) {\n  vec2 pos = vec2(-1.0, -1.0);\n  vec2 offset = 1.0 / vec2(gridSize);\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n\n  int yIndex = gl_InstanceID / gridSize[0];\n  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);\n\n  vec2 yIndexFP64 = vec2(float(yIndex), 0.);\n  vec2 xIndexFP64 = vec2(float(xIndex), 0.);\n  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);\n  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);\n\n  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);\n  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);\n\n  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);\n}\n",fs:"#version 300 es\n#define SHADER_NAME gpu-aggregation-all-fs\n\nprecision highp float;\n\nin vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform bool combineMaxMin;\nout vec4 fragColor;\nvoid main(void) {\n  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n  if (textureColor.a == 0.) {\n    discard;\n  }\n  fragColor.rgb = textureColor.rgb;\n  fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;\n}\n",modules:["fp64"],shaderCache:t,vertexCount:1,drawMode:0,isInstanced:!0,instanceCount:i*n,attributes:{position:[0,0]}})}},{key:"getMeanTransform",value:function(e){return this.meanTransform?this.meanTransform.update(e):this.meanTransform=new v.a(this.gl,Object.assign({},{vs:"#define SHADER_NAME gpu-aggregation-transform-mean-vs\nattribute vec4 aggregationValues;\nvarying vec4 meanValues;\n\nvoid main()\n{\n  bool isCellValid = bool(aggregationValues.w > 0.);\n  meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);\n  meanValues.w = aggregationValues.w;\n}\n",_targetTextureVarying:"meanValues"},e)),this.meanTransform}},{key:"renderAggregateData",value:function(e){var t=e.cellSize,a=e.viewport,i=e.gridTransformMatrix,n=e.projectPoints,r=this.state,o=r.numCol,s=r.numRow,g=r.windowSize,u=r.maxMinFramebuffers,l=r.minFramebuffers,c=r.maxFramebuffers,d=r.weights,f=[o,s],h={blend:!0,depthTest:!1,blendFunc:[1,1]},v={viewport:a},m={windowSize:g,cellSize:t,gridSize:f,uProjectionMatrix:i,uProjectionMatrixFP64:U(i),projectPoints:n};for(var p in d){var x=d[p],M=x.needMin,w=x.needMax,b=M&&w&&d[p].combineMaxMin;this.renderToWeightsTexture({id:p,parameters:h,moduleSettings:v,uniforms:m,gridSize:f}),b?this.renderToMaxMinTexture({id:p,parameters:Object.assign({},h,{blendEquation:P}),gridSize:f,minOrMaxFb:u[p],clearParams:{clearColor:[0,0,0,y]},combineMaxMin:b}):(M&&this.renderToMaxMinTexture({id:p,parameters:Object.assign({},h,{blendEquation:A}),gridSize:f,minOrMaxFb:l[p],clearParams:{clearColor:[y,y,y,0]},combineMaxMin:b}),w&&this.renderToMaxMinTexture({id:p,parameters:Object.assign({},h,{blendEquation:C}),gridSize:f,minOrMaxFb:c[p],combineMaxMin:b}))}}},{key:"renderToMaxMinTexture",value:function(e){var t=e.id,a=e.parameters,i=e.gridSize,n=e.minOrMaxFb,r=e.combineMaxMin,o=e.clearParams,s=void 0===o?{}:o,g=this.state.framebuffers,u=this.gl,l=this.allAggregationModel;n.bind(),u.viewport(0,0,i[0],i[1]),Object(m.a)(u,s,(function(){u.clear(16384)})),l.draw({parameters:a,uniforms:{uSampler:g[t].texture,gridSize:i,combineMaxMin:r}}),n.unbind()}},{key:"renderToWeightsTexture",value:function(e){var t=e.id,a=e.parameters,i=e.moduleSettings,r=e.uniforms,o=e.gridSize,s=this.state,g=s.framebuffers,u=s.equations,l=s.weightAttributes,c=s.weights,d=this.gl,f=this.gridAggregationModel,h=c[t].operation;g[t].bind(),d.viewport(0,0,o[0],o[1]);var v=h===M.a.MIN?[y,y,y,0]:[0,0,0,0];Object(m.a)(d,{clearColor:v},(function(){d.clear(16384)}));var p={weights:l[t]};if(f.draw({parameters:Object.assign({},a,{blendEquation:u[t]}),moduleSettings:i,uniforms:r,attributes:p}),g[t].unbind(),h===M.a.MEAN){var x=this.state,w=x.meanTextures,b=x.textures,A={_sourceTextures:{aggregationValues:w[t]},_targetTexture:b[t],elementCount:b[t].width*b[t].height};this.getMeanTransform(A).run({parameters:{blend:!1,depthTest:!1}}),g[t].attach(Object(n.a)({},36064,b[t]))}}},{key:"runAggregationOnGPU",value:function(e){this.updateModels(e),this.setupFramebuffers(e),this.renderAggregateData(e);var t=this.getAggregateData(e);return this.setState({results:t}),t}},{key:"setupFramebuffers",value:function(e){var t=this.state,a=t.numCol,i=t.numRow,r=t.textures,o=t.framebuffers,s=t.maxMinFramebuffers,g=t.minFramebuffers,u=t.maxFramebuffers,l=t.resources,c=t.meanTextures,d=t.equations,f=t.weights,h={width:a,height:i};for(var v in f){var m=f[v],p=m.needMin,x=m.needMax,w=m.combineMaxMin,b=m.operation;r[v]=f[v].aggregationTexture||r[v]||B(this.gl,{id:"".concat(v,"-texture"),width:a,height:i}),r[v].resize(h);var y=r[v];b===M.a.MEAN&&(c[v]=c[v]||B(this.gl,{id:"".concat(v,"-mean-texture"),width:a,height:i}),c[v].resize(h),y=c[v]),o[v]?o[v].attach(Object(n.a)({},36064,y)):o[v]=k(this.gl,{id:"".concat(v,"-fb"),width:a,height:i,texture:y}),o[v].resize(h),d[v]=S[b],(p||x)&&(p&&x&&w?s[v]||(l["".concat(v,"-maxMin")]=B(this.gl,{id:"".concat(v,"-maxMinTex")}),s[v]=k(this.gl,{id:"".concat(v,"-maxMinFb"),texture:l["".concat(v,"-maxMin")]})):(p&&(g[v]||(l["".concat(v,"-min")]=B(this.gl,{id:"".concat(v,"-minTex")}),g[v]=k(this.gl,{id:"".concat(v,"-minFb"),texture:l["".concat(v,"-min")]}))),x&&(u[v]||(l["".concat(v,"-max")]=B(this.gl,{id:"".concat(v,"-maxTex")}),u[v]=k(this.gl,{id:"".concat(v,"-maxFb"),texture:l["".concat(v,"-max")]})))))}}},{key:"setupModels",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.gridAggregationModel&&this.gridAggregationModel.delete(),this.gridAggregationModel=this.getAggregationModel(e),this.allAggregationModel||(this.allAggregationModel=this.getAllAggregationModel())}},{key:"setupWeightAttributes",value:function(e){var t=this.state,a=t.weightAttributes,i=t.vertexCount,n=t.weights,r=t.resources;for(var o in n){var s=n[o].values;if(Array.isArray(s)||s.constructor===Float32Array){p.a.assert(s.length/3===i);var g=Array.isArray(s)?new Float32Array(s):s;a[o]instanceof d.a?a[o].setData(g):(r["".concat(o,"-buffer")]=new d.a(this.gl,g),a[o]=r["".concat(o,"-buffer")])}else p.a.assert(s instanceof d.a),a[o]=s}}},{key:"trackGPUResultBuffers",value:function(e,t){var a=this.state.resources;for(var i in e)if(e[i])for(var n=0;n<R.length;n++){var r=R[n];if(e[i][r]&&t[i][r]!==e[i][r]){var o="gpu-result-".concat(i,"-").concat(r);a[o]&&a[o].delete(),a[o]=e[i][r]}}}},{key:"updateModels",value:function(e){var t=this.gl,a=e.positions,i=e.positions64xyLow,n=e.changeFlags,r=this.state,o=r.numCol,s=r.numRow,g={},u=!1;if(e.fp64!==this.state.fp64&&(this.setupModels(e.fp64),this.setState({fp64:e.fp64}),u=!0),n.dataChanged||!this.state.positionsBuffer){var l=this.state,c=l.positionsBuffer,f=l.positions64xyLowBuffer;c&&c.delete(),f&&f.delete();var h=a.length/2;c=new d.a(t,new Float32Array(a)),f=new d.a(t,{data:new Float32Array(i),accessor:{size:2}}),this.setState({positionsBuffer:c,positions64xyLowBuffer:f,vertexCount:h}),this.setupWeightAttributes(e),u=!0}if(u){var v=this.state,m=v.vertexCount,p=v.positionsBuffer,x=v.positions64xyLowBuffer;g.positions=p,e.fp64&&(g.positions64xyLow=x),this.gridAggregationModel.setVertexCount(m),this.gridAggregationModel.setAttributes(g)}(n.cellSizeChanged||n.viewportChanged)&&this.allAggregationModel.setInstanceCount(o*s)}}]),e}()}}]);